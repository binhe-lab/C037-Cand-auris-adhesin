---
title: "Analyze predicted adhesins mapped to Orthogroups MCL v5"
author: "Bin He"
date: "5/31/2020"
output:
  html_notebook:
    toc: yes
    toc_float: yes
    toc_depth: 5
  html_document:
    toc: yes
    toc_depth: '5'
    df_print: paged
---

```{r setup, cache=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# set the root directory to be the output folder for OrthoMCL
# note that with the Rproject set, the default working directory
# is where the .Rproj file is.
knitr::opts_knit$set(root.dir = normalizePath("../../output/OrthoMCL/"))
knitr::opts_knit$get("root.dir")
```

```{r load_libraries, echo=FALSE}
# install the package if not already available
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages("tidyverse")
if (!requireNamespace("rentrez", quietly = TRUE))
    install.packages("rentrez")

# load the package
suppressMessages(library(tidyverse))
suppressMessages(library(rentrez))
```

## Questions

Are the known and _predicted_ adhesin genes from _C. auris_, _C. albicans_ and _C. glabrata_ from the same group of adhesin families? In other words, do they use an ancestral pool of adhesin genes or did they evolve species-specific ones by co-option or _de novo_ evolution? If they share certain families, are the number of paralogs (members of a family) similar or different?

_Update 2020-05-31_

After my initial analysis of the OrthoMCL results (see [`OrthoMCL.Rmd`](https://github.com/binhe-lab/C037-Cand-auris-adhesin/blob/master/01-global-adhesin-prediction/analysis/protein-family-classification/OrthoMCL.Rmd)), I found that some of the orthogroups don't make obvious sense in terms of mediating adhesion, such as gene families annotated as alcohol dehydrogenases and other enzymes. Some of them may genuinely be relevant, such as aspartyl protease, which could be involved in cell wall remodeling triggered by host-fungal interaction. However, it does seem likely to me that the list of predicted adhesins contain an appreciable amount of false positives. To resolve this, I plan to take two approaches: 1) narrow down the list by including only those genes predicted by both FungalRV and FaaPred. This should reduce false positive rate, although it comes at the cost of higher false negative rates. 2) instead of analyzing the orthogroup mapping assuming all the predicted adhesins are correct, use the functional annotation for the orthogroups to vet the adhesins, and remove predictions that obviously _don't make sense_. Similarly, I can combine other predicted features such as Signal Peptide, GPI anchor and low complexity repeat regions to further eliminate potential false positives. In this document I will first try the FaaPred dataset.

## Approach
As previously, the OrthoMCL results were obtained using the VEuPathDB's [Galaxy site](http://veupathdb.globusgenomics.org/) to map the predicted adhesins from all five genomes to "orthogroups". These are pre-computed groups of putative orthologous protein sequences. These are calculated using the OrthoMCL program. Here is a [description](https://orthomcl.org/orthomcl/about.do#background) of how that is done. 

Briefly

- All-v-all BLASTP of the proteins.
- Compute percent match length
    - Select whichever is shorter, the query or subject sequence. Call that sequence S.
    - Count all amino acids in S that participate in any HSP (high scoring pairs, from BLAST local alignment).
    - Divide that count by the length of S and multiply by 100
- Apply thresholds to blast result. Keep matches with E-Value \< 1e-5 percent and match length \>= 50%
- Find potential in-paralog, ortholog and co-ortholog pairs using the Orthomcl Pairs program. (These are the pairs that are counted to form the Average % Connectivity statistic per group.)
- Use the MCL program to cluster the pairs into groups

## Data

- OrthoMCL output, including `mappedGroups.txt`, `MCS.tabular` and `paralogPairs.txt`.
    - `mappedGroups.txt`: the mapping between the proteins in the input file and the pre-calculated Orthogroups. 
    - `paralogPairs.txt`: pairwise distance calculated among the input sequences. 
    - `MCS.tabular`: the clustered proteins based on the `paralogPairs.txt`, which only include those sequences that don't get mapped to the existing Orthogroups.
- FungalRV predictions: `../FungalRV/all-fungalrv-results-20200529.txt`
- FaaPred predictions: `../Faapred/all-faapred-seq-names-20200531.txt`

### load data

Note! Please make sure that the threshold used below is correct before interpreting the remaining of this document
```{r load_adhesin_prediction}
# -------- Change Me! ----------
# 0. Set the fungalRV score threshold
#    The website application's default is 0, but the paper recommends 0.511 to achieve the best balance
#   between true positive and false positive
frv.th = 0.511
# -----------END ---------------

# 1. FungalRV
#    the following file contains the metadata for all genes
#    header: species, strains, protein_id and FungalRV score
#    threshold used by current version of Fungal RV: Score > 0 
frv.res <- read_tsv("../FungalRV/all-fungalrv-results-20200529.txt", comment = "#", col_types = "cccd", na = "Can't be processed")

# 2. FaaPred
faa.res <- scan("../Faapred/all-faapred-seq-names-20200531.txt", what = "string")

# 3. Make T/F variables for FungalRV and FaaPred results
adhesin <- frv.res %>% 
  mutate(fungalRV = ifelse(Score > frv.th, TRUE, FALSE),
         faapred = ifelse(ID %in% faa.res, TRUE, FALSE))
```

Load OrthoMCL mapping for proteins from the _Candida_ species
```{r load_orthomcl_mapping_no_scer}
# the following file contains the mapped results for the proteins with FungalRV score > 0 in all proteomes except for _S. cerevisiae_
frv.mapped <- read_tsv("all-fungalRV-orthoMCL-v5/mappedGroups-20200309.txt", col_types = "ccciidd")

# merge the frv.mapped with frv.res to provide gene information
frv.mapped.rest <- frv.mapped %>% 
  left_join(adhesin, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, group_id = orthomcl_group_id, frv_score = Score, fungalRV, faapred)

head(frv.mapped.rest, 3)
```

We need to process _S. cerevisiae_ data separately because instead of using the OrthoMCL mapping program, I downloaded the preprocessed results from [FungiDB](https://fungidb.org)

Note: the code below is _not_ run by default. Only run it when the _S. cerevisiae_ mapping data are updated.
```{r convert_scer_ID, echo=TRUE, eval=FALSE}
# the S. cerevisiae mapping data is downloaded from fungiDB (which is from OrthoMCL v5)
scer.mapped <- read_tsv("all-fungalRV-orthoMCL-v5/S_cerevisiae_orthoMCL_v5_download.txt", col_types = "ccccccccc")
# rearrange the columns and make any non-orthomcl-group-ids "NA"
scer.mapped <- scer.mapped %>%
  select(gene_id, description, orthogroup_id, pfam_id, pfam_description, geneName, entrez_id) %>% 
  mutate(orthogroup_id = ifelse(substr(orthogroup_id, 1, 4)=="OG5_", orthogroup_id, "NA"))

# collect predicted adhesins in S. cerevisiae by FungalRV
# note the threshold here is not altered, because my goal is to convert as many IDs 
# as entrez_link() allows doing so for all _S. cerevisiae_ is not possible due to 
# NCBI's API limit, but can be achieved by splitting the list into several batches 
# of hundreds. I didn't do so since we don't need the information for most of the 
# proteome (anything with score below zero are considered non-adhesin)
frv.scer <- adhesin %>% 
  filter(Species == "S_cerevisiae", Score > 0)

# translate these IDs to entrez_id so we can bring in the orthomcl mapping results
lnk <- entrez_link(dbfrom = "protein", id = frv.scer$ID, db = "gene", by_id = TRUE)
frv.scer$entrez_id <- sapply(lnk, function(x) x$link$protein_gene)

# pull in the orthogroup and other annotation
frv.mapped.scer <- frv.scer %>% 
  left_join(select(scer.mapped, group_id = orthogroup_id, entrez_id), by = c("entrez_id"="entrez_id")) %>% 
  select(Species, Strain, protein_id = ID, group_id, frv_score = Score, fungalRV, faapred)
write_tsv(frv.mapped.scer, "all-fungalRV-orthoMCL-v5/S_cerevisiae_mapped_w_entrezID.txt")
```

```{r process_and_merge_scer_data}
# read S. cerevisiae results generated above
frv.mapped.scer <- read_tsv("all-fungalRV-orthoMCL-v5/S_cerevisiae_mapped_w_entrezID.txt", col_types = "ccccdll")
# merge Scer results with the rest
frv.mapped.all <- rbind(frv.mapped.rest, filter(frv.mapped.scer, substr(group_id,1,8) != "OG5_scer"))

str(frv.mapped.all)
```

Note that _S. cerevisiae_ data contain a number of orthogroups with unusual group_id, such as  `r head(frv.mapped.scer %>% filter(substr(group_id,1,8) == "OG5_scer") %>% pull(group_id))`. These groups have only one member, that is, the _S. cerevisiae_ gene. However, when I search in the OrthoMCL-DB v6r1, some of them, like "OG5_scer|scer_s288c__YJL116C" coorespond to "OG6_1300006", which do contain 8 core members and 110 peripheral members. For the moment, though, I **excluded** them from "mapped" list by assigning "NA" to their group_id.

Now let's load the Markov clustering results. This files contains the grouping produced by the MCL algorithm for those sequences that don't map to the orthomcl groups, and cluster them using the all-against-all blastp scores among themselves using the Markov Clustering Algorithm (MCL)
```{r load_mcs, warning=FALSE}
# the following file contains unmapped genes grouped by MCS algorithm
#frv.mcs <- read_tsv("all-fungalRV-orthoMCL-v5/MCS-20200605.tabular", comment = "#", col_types = "cc")
frv.mcs <- read_tsv("all-fungalRV-orthoMCL-v5/MCS-20200605.tabular", col_names = FALSE, col_types = "ccc")
frv.mcs$group_id <- paste("MCS",1:nrow(frv.mcs), sep = "_")
frv.mcs.long <- frv.mcs %>%  
  pivot_longer(-group_id, names_to = "member", values_to = "protein_id") %>% 
  # remove empty entries
  filter(!is.na(protein_id)) %>% 
  select(protein_id, group_id) %>% 
  left_join(adhesin, by = c("protein_id" = "ID")) %>% 
  select(Species, Strain, protein_id, group_id, frv_score = Score, fungalRV, faapred)

# merge with the mapped results
frv.cmbd <- bind_rows( mapped = frv.mapped.all, mcs = frv.mcs.long, .id = "type")
frv.cmbd %>% 
  filter(type == "mcs") %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n)
```
**Clearly, the MCS groups almost certainly represent the orthologs in the three _C. auris_ strains. No additional groups were recovered.**

**In the analysis below, we will use `frv.mapped.all`**

Lastly, we will load the meta-table downloaded from [fungiDB beta site](https://beta.fungidb.org/fungidb.beta/app/). Note that the OrthoMCL groups are based on OrthoMCL-v6r1, but the other meta-information are not specific to that version.
```{r load_fungidb_meta_table}
fungidb <- read_tsv("all-fungalRV-orthoMCL-v6r1/all_species_orthogroup_results_from_fungidb.txt", col_types = "ccccccicc", na = "N/A")
fungidb$organism <- with(fungidb, factor(organism, levels = unique(organism), labels = c("C_auris", "C_albicans", "C_glabrata", "S_cerevisiae")))
```

## Analysis

### A. How many predicted adhesins were successfully mapped in each species/strain?

First, let's check the prediction results.

- The "**Submitted**" represent the number of proteins getting a FungalRV score greater than zero - this is the default cutoff of the FungalRV web application, but is not the recommended cutoff as it potentially includes many false positives. We use this to "nominate" candidate adhesins, and also these were submitted to OrthoMCL program for mapping.
- The "**FungalRV**" group were those genes with a FungalRV score greater than the cutoff of 0.511, which is what the authors recommended.
- The "**FaaPred**" group were those among the FungalRV score > 0 that were predicted by FaaPred to be an adhesin. Because we didn't run FaaPred on ALL the genes, due to the 25 sequence limits of their web app and lack of access to their source code, this set is only a subset of what FaaPred would have predicted in these genomes.
- The "**Both**" grouop represent the intersection of FungalRV and FaaPred predictions.

```{r prediction_results, echo=FALSE}
# total number of adhesins submitted per species
frv.stat <- adhesin %>% 
  group_by(Species, Strain) %>% 
  summarize(FungalRV = sum(fungalRV, na.rm = T), 
            FaaPred = sum(faapred, na.rm = T), 
            Both = sum(fungalRV & faapred),
            Submitted = sum(Score > 0, na.rm = T), 
            Total = n())
print(frv.stat)
```

Next let's look at how many of the sequences submitted to OrthoMCL were successfully mapped.
```{r percent_mapped_v5, echo=FALSE}
# combined both mapped and MCS clustered
#frv.cmbd %>% 
#  group_by(Strain) %>% 
#  summarize(mapped = sum(type == "mapped"),self_group = sum(type == "mcs")) %>% 
#  right_join(frv.stat, by = c("Strain" = "Strain")) %>% 
#  mutate(unmapped = Submitted - mapped - self_group) %>% 
#  select(Species, Strain, mapped, self_group, unmapped, Submitted)

frv.mapped.stat <- frv.mapped.all %>% 
  count(Strain) %>% 
  right_join(frv.stat, by = c("Strain" = "Strain")) %>% 
  mutate(mapped = n, unmapped = Submitted - mapped) %>% 
  select(Species, Strain, mapped, unmapped, Submitted)

print(frv.mapped.stat)
# plot the results
frv.mapped.stat %>% 
  select(-Submitted) %>% 
  pivot_longer(cols = c(mapped, unmapped), names_to = "status", values_to = "n") %>% 
  mutate(status = ordered(status, levels = c("unmapped","mapped"))) %>% 
  ggplot(aes(x = Strain, y = n, fill = status)) + geom_col() + coord_flip() + scale_fill_brewer(palette = "Paired")
```

Note that although all _S. cerevisiae_ proteins appear to be "mapped", `r length(frv.mapped.scer %>% filter(substr(group_id,1,8) == "OG5_scer") %>% pull(group_id))` belong to those unusual "OG5_scer|scer_S288c_xxx" groups.

### B. Reduce the three _C. auris_ strains to a single superset

While the individual strains could reveal variation within species, the unequal assembly quality of the three strains' genome makes this approach less convincing. Instead, we could take advantage of the three genomes to come up with a superset of adhesins that "exist" in the _C. auris_ population. Here the idea is to use the OrthoMCL mapping to remove redundant genes. Among the _C. auris_ genes that map to one of the OrthoMCL groups, we pick one of them as a representative, e.g. choose the one that is the longest.

#### Count the number of genes in each _C. auris_ strain belonging to every orthogroup
Let's first examine the grouping of the _C. auris_ proteins, including the OrthoMCL groups and the MCL clustering result for those not mapped to the existing groups (only the top seven rows are shown, the rest have 0 or 1 member in each strain)
```{r examine_C_auris_proteins, echo=FALSE}
# extract only the C. auris entries
caur <- frv.mapped.all %>% 
  filter(Species == "C_auris", frv_score > 0) 

# let's check the number of genes in each orthogroup by strain
caur.wide <- caur %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  arrange(desc(B11220+B11221+B8441))
head(caur.wide, n = 7)
```
_Discussion_

We can see that most of the orthogroups contain one or zero gene in each strain. A few orthogroups contain multiple members. I think it will be interesting to pull one of the latter groups out, e.g. OG5_132045, extract all the sequences in that group and build a gene geneaology tree.

#### Reconstruct the gene tree for a representative orthogroup
```{r extract_multiple_member_groups, eval=FALSE}
example_set <- frv.mapped.all %>% filter(group_id == "OG5_132045") %>% pull(protein_id)
cat(example_set, file = "all-fungalRV-orthoMCL-v5/subset/OG5_132045.txt", sep = "\n")
```

Next I used a custom script to extract the fasta sequences, which were aligned and submitted to a tree construction algorithm to infer the gene geneaology relationship.

![**Figure 1. Best RAxML tree for OG5_132045 (run from 20 random maximal parsimony tree, no bootstrap)**](../../output/OrthoMCL/all-fungalRV-orthoMCL-v5/OG5_132045/RAxML_bestTree.test.png)

_Discussion_

It's clear that gene duplications happened in _C. albicans_ and _C. auris_. Within _C. auris_, it appears that most of the genes are shared across the three strains, suggesting that the gene duplications happened before the split of those three strains from their common ancestor.

#### Reduce the three _C. auris_ sets to a pan _C. auris_ set

Next I'd like to reduce three _C. auris_ sets into a pan-species set. Since all I need  in the following analysis is to count the _number_ of proteins in each orthogroup, I don't really care which member I retain and which I leave out. To do so, I will create a new variable in `caur` that records the strain with the largest number of proteins in each group. Then, using both `group_id` and this new variable, I can obtain a list of `protein_id` that I want to retain.
```{r reduce_caur_set, echo=FALSE}
caur.strains <- c("B11220","B8441","B11221") # arranged in the order of genome assembly completeness. B11220 is the most recently updated, and is the most well assembled; B8441 is still the reference strain in most databases, e.g. fungidb
caur.reduced <- caur.wide %>% 
  # find out which strain has the largest number of members in each group
  mutate(use.strain = caur.strains[which.max(c(B11220, B8441, B11221))]) %>% 
  select(group_id, use.strain) %>% 
  # append this information to the caur data frame (subset of the frv.cmbd)
  right_join(caur, by = c("group_id" = "group_id")) %>% 
  # only retain rows where the Strain matches the `use.strain`
  filter(Strain == use.strain) %>% 
  select(Species, Strain, protein_id, group_id)
```

Original set
```{r original_set, echo = FALSE}
caur %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  arrange(desc(B11220+B11221+B8441)) %>% 
  head(n = 3)
```

Reduced set
```{r reduced_set, echo=FALSE}
caur.reduced %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  mutate(total = sum(c(B11220,B11221,B8441), na.rm = TRUE)) %>% 
  arrange(desc(total)) %>%
  select(group_id, B11220, B11221, B8441) %>% 
  head(n = 3)
```

Now let's make a new data frame holding the reduced _C. auris_ set and the other species
```{r reduced_data_frame}
# get the list of C. auris protein_id that need to be removed
caur.remove <- setdiff(caur$protein_id, caur.reduced$protein_id)
# remove tho corresponding entries from the combined data set 
frv.reduced <- frv.mapped.all %>% 
  filter(!protein_id %in% caur.remove)
```

### C. Proportion of shared vs species-specific (predicted) adhesins
_Goal_

Use a bar or pie chart to represent the number (or proportion) of predicted adhesins that fall in one of the four categories
1. Unmapped
1. Mapped to a group that is not shared with any of the remaining 3 species.
1. Mapped to a group that is shared by one other species.
1. Mapped to a group that is shared with two other species.
1. Mapped to a group that is shared across all four species.

_Approach_

1. Subset the data
1. Separately count the number of proteins in each species and group them based on whether they belong to an orthogroup or self_group that is shared by at least one other species.

This analysis will be done on four different subsets of the data.

1. All genes with a FungalRV score greater than zero -- this is what we submitted to OrthoMCL, and also what is used in many other analyses as the input set. It probably contains a fair number of false positives.
1. Genes with a FungalRV score greater than `r frv.th` -- this is the recommended score cutoff for FungalRV.
1. Genes with a FungalRV score greater than 0 and also predicted by FaaPred to be adhesins.
1. Genes that are predicted by FungalRV (recommended threshold) and FaaPred

#### 1. FungalRV_0

Let's first examine the group membership, ordered by the size of each group in the reduced data set in descending order.
```{r}
# subset the data
frv.tally = list()
frv.tally$frv_low <- frv.reduced %>% 
  # no filtering
  # count the number of genes in each strain belonging to one orthogroup
  group_by(group_id) %>% 
  count(Species) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Species, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Total = C_albicans+C_auris+C_glabrata+S_cerevisiae) %>% 
  select(group_id, C_auris, C_albicans, C_glabrata, S_cerevisiae, Total) %>% 
  arrange(desc(Total))

frv.tally$frv_low %>% filter(Total > 2)
```

Next let's compute the number of genes in each species belonging to the four groups.
```{r}
# for each orthogroup, count the number of species with at least one member
frv.group.Nsps = list()
frv.group.Nsps$frv_low <- frv.reduced %>%
  group_by(group_id) %>%
  summarize(N_sps = length(unique(Species)))

# for each species, count the number of genes belonging to groups with 4,3,2 or 1 species representation
frv.mapped.low <- frv.reduced %>%
  # bring in the species number computed above
  left_join(frv.group.Nsps$frv_low) %>% 
  group_by(Species) %>% 
  count(N_sps)
```

Now we will plot the proportions for each species depending on whether the predicted adhesin belongs to an orthogroup that is specific to one species (`N_sps=1`), shared across 2, 3 or all 4 species (`N_sps = 2,3,4`), and also genes not mapped to any orthogroup (`N_sps = unmapped`)
```{r, echo=FALSE}

# append the unmapped number
frv.unmapped.low <-  frv.mapped.stat %>% 
  group_by(Species) %>% 
  summarize(n = as.integer(mean(unmapped))) %>% 
  mutate(N_sps = 0) %>% 
  select(Species, N_sps, n)

# combine mapped and unmapped and save in the group status list
frv.group.sps = list()
frv.group.sps$frv_low <- rbind(frv.mapped.low, frv.unmapped.low) %>% 
  # calculate the proportions
  # from https://stackoverflow.com/questions/40249943/adding-percentage-labels-to-a-bar-chart-in-ggplot2
  mutate(pct = prop.table(n), 
         N_sps = factor(N_sps, levels = 0:4, labels = c("unmapped",1,2,3,4))) %>% 
  arrange(Species, N_sps)

ggplot(frv.group.sps$frv_low, aes(x = Species, y = n, fill = N_sps, label = scales::percent(pct, accuracy = 1))) + 
  geom_bar(stat = "identity", width = 0.5) + 
  geom_text(position = position_stack(vjust = 0.5), size = 3) +
  coord_flip() + scale_fill_brewer(palette = "Paired") + theme_minimal() +
  ggtitle("Number of predicted adhesins with shared orthogroup") + ylab("# of predicted adhesins")
```

Now let's learn something about the top OG groups, e.g. what functional domains do these orthogroups have in common? What EC and GO terms are they associated with?

To answer this question, we will collect the list of orthogroup id's and paste them manually onto the OrthoMCL-DB website's [search group id tool](https://orthomcl.org/orthomcl/showQuestion.do?questionFullName=GroupQuestions.ByNameList), and then download the output as a custom table.

```{r orthogroup_output, include = FALSE}
# print the top orthogroups' IDs
cat(paste(frv.tally$frv_low$group_id, collapse = ","))
# copy and paste the list to https://orthomcl.org/orthomcl/showQuestion.do?questionFullName=GroupQuestions.ByNameList
# then choose the columns to report. I chose
# num. sequences | average % identity | domains | EC numbers | Group | Keywords
```

```{r add_og_information}
# read in the results
frv.mcl5.og <- read_tsv("all-fungalRV-orthoMCL-v5/v5-orthogroups-summary-20200608.txt", col_types = "cidcdcc", na = "N/A")

# merge the tables
frv.mcl5.sum <- list()
frv.mcl5.sum$frv_low <- frv.tally$frv_low %>% 
  left_join(select(frv.mcl5.og, group, domains, keywords), by = c("group_id" = "group")) %>% 
  filter(Total > 3) %>% 
  select(group_id, domains, keywords)
```

#### 2. FungalRV_`r frv.th`
Next we turn to the smaller set based on the recommended cutoff for FungalRV
```{r, echo=F} 
# subset the data
frv.tally$frv_high <- frv.reduced %>% 
  # based on FungalRV recommended cutoff
  filter(fungalRV) %>% 
  # count the number of genes in each strain belonging to one orthogroup
  group_by(group_id) %>% 
  count(Species) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Species, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Total = C_albicans+C_auris+C_glabrata+S_cerevisiae) %>% 
  select(group_id, C_auris, C_albicans, C_glabrata, S_cerevisiae, Total) %>% 
  arrange(desc(Total))

frv.tally$frv_high
```

Next let's compute the number of genes in each species belonging to the four groups. This time I also added the unmapped (filtered by the same score threshold).
```{r, echo=FALSE, warning=FALSE}
# for each orthogroup, count the number of species with at least one member
frv.group.Nsps$frv_high <- frv.reduced %>%
  # add the filter
  filter(fungalRV) %>% 
  group_by(group_id) %>%
  summarize(N_sps = length(unique(Species)))

# for each species, count the number of genes belonging to groups with 4,3,2 or 1 species representation
frv.mapped.high <- frv.reduced %>%
  # filter
  filter(fungalRV) %>% 
  # bring in the species number computed above
  left_join(frv.group.Nsps$frv_high) %>% 
  group_by(Species) %>% 
  count(N_sps)

# for each species, count the number of unmapped genes that meet the criteria
# this will be combined with the mapped tally later
frv.unmapped.high <- adhesin %>% 
  # note that the adhesin dataset still has three C. auris genomes
  # for convenience, we will use one strain, B11220, as the reference
  filter(fungalRV & !(Strain %in% c("B11221","B8441"))) %>% 
  # this counts the total # of proteins in each species meeting the criteria
  count(Species, name = "submitted") %>% 
  left_join(frv.reduced %>% filter(fungalRV) %>% count(Species, name = "mapped")) %>% 
  mutate(N_sps = 0, n = submitted-mapped) %>% 
  select(Species, N_sps, n)

# combine the mapped & group classified with the unmapped
frv.group.sps$frv_high <- rbind(frv.mapped.high, frv.unmapped.high) %>%
  mutate(pct = prop.table(n), 
         N_sps = factor(N_sps, levels = 0:4, labels = c("unmapped",1,2,3,4))) %>% 
  arrange(Species, N_sps)

ggplot(frv.group.sps$frv_high, aes(x = Species, y = n, fill = N_sps, label = scales::percent(pct, accuracy = 1))) + 
  geom_bar(stat = "identity", width = 0.5) + 
  geom_text(position = position_stack(vjust = 0.5), size = 3) +
  coord_flip() + scale_fill_brewer(palette = "Paired") + theme_minimal() +
  ggtitle("Number of predicted adhesins with shared orthogroup") + ylab("# of predicted adhesins")
```

_Discussion_

Notice that the proportion of species-specific orthogroups generally goes down for all species. However, one question arises -- see below.

##### _C. auris_ specific orthogroups
Jan raised the question of why do we find _C. auris_ specific orthogroups -- given that _C. auris_ is the only species not included in the construction of the OrthoMCL-DB v5, the above observation makes one wonder whether these are genuinely _C. auris_ co-option of ancestrally non-adhesins to be used as adhesins, or are they false positives, or is it possible that the choice of the single cutoff, i.e. 0.511, leaves out members of this group in the other species.

The first question we can ask is to compare the score distribution for genes in the different category.
```{r score_distribution_by_shared_group}
frv.reduced %>% 
  filter(fungalRV) %>% 
  left_join(frv.group.Nsps$frv_high, by = c("group_id" = "group_id")) %>% 
  mutate(N_sps = factor(N_sps)) %>% 
  ggplot(aes(x = N_sps, y = frv_score)) + 
  geom_boxplot(position = position_dodge(0.9), width = 0.5) +
  facet_wrap(~Species) + ylab("FungalRV Score") + xlab("Shared among N species")
  
```

_Discussion_

- The pattern doesn't lend support to my initial hunch that the proteins mapped to orthogroups not shared by other species have low FungalRV scores. 
- There is a curious pattern where the orthogroups shared across three species consistently have lower scores. My suspicion is that this is due to the four species naturally forming two groups based on their evolutionary relationship -- those shared between two species are most likely between _C. glabrata_ and _S. cerevisiae_, or between _C. albicans_ and _C. auris_. For orthogroups shared across three species, the most parsimonious explanation would be loss in one of the species. The lower average score indicate that these orthogroups are more likely to be false positives.
- In all species except _C. auris_, the proteins mapped to orthogroups present in all four species have the highest mean FungalRV score. But across all four species, the orthogroups shared among three of the four species have the lowest FungalRV score.
- So the other idea is to examine those orthogroups and check whether the domains make any sense.

```{r caur_specific_group, echo=FALSE, warning=FALSE}
frv.tally$frv_high %>% 
  filter(C_auris == Total) %>%
  left_join(frv.mcl5.og, by = c("group_id" = "group")) %>% 
  select(group_id, C_auris, n.seqs, avg.id, avg.connect, domains, keywords)
```

I then searched the first orthogroup on OrthoMCL website and found [OG5_138848](https://orthomcl.org/orthomcl/showRecord.do?name=GroupRecordClasses.GroupRecordClass&group_name=OG5_138848) has many _C. albicans_ genes, e.g. [C4_04080C](http://www.candidagenome.org/cgi-bin/locus.pl?locus=C4_04080C_B&organism=C_albicans_SC5314) (= [XP_717105.1](https://www.ncbi.nlm.nih.gov/protein/XP_717105.1?report=fasta) ). To see why this protein is not included in the `frv.reduced`, I looked up its prediction result `r adhesin %>% filter(ID == "XP_717105.1")` and found that it has a negative FungalRV score. So it's not even submitted to the OrthoMCL mapping. I verified this result by submitting the sequence of this protein to FungalRV again. I also submitted it to [FaaPred](http://bioinfo.icgeb.res.in/faap/query.html), which also classified it as non-adhesin. I then verified that one of the _C. auris_ proteins, PIS51941.1, is indeed predicted by both FungalRV and FaaPred to be an adhesin. The possible explanation for this result is either FungalRV and FaaPred missing the _C. albicans_ genes, whose annotations do contain words like "cell wall related" "GPI-anchor" etc., or, it could be that the _C. auris_ genes have taken those ancestral cell-wall related, GPI-anchor proteins and evolved them into adhesin molecules.

Another _C. albicans_ gene in this orthogroup, [C4_04070C](http://www.candidagenome.org/cgi-bin/locus.pl?locus=C4_04070C_B&organism=C_albicans_SC5314) (=XP_717106.1) did get a positive FungalRV score that is lower than the `r frv.th` cutoff, but is predicted by FaaPred to be an adhesin. `r frv.reduced %>% filter(protein_id == "XP_717106.1")` So this protein would have been included in the `FungalRV_0` set as well as the `FaaPred` set.

Another orthogroup, OG5_157055, does have _C. albicans_ members. `r frv.reduced %>% filter(group_id == "OG5_157055")`, but its FungalRV score is just below the `r frv.th` cutoff.

_Conclusion & Next Steps_

- The observation of _C. auris_ orthogroups can be due to a number of reasons or a combination of them: the single cutoff resulting in orthologs in the rest three species falling "just below" the cutoff, or the _C. auris_ protein represents a _de novo_ evolution, or co-option, of an ancestral cell-wall protein that doesn't have the adhesin function.
- To partially address this issues, I could
    1. Perform the analysis on FaaPred subset to compare.
    1. Analyze the results using OrthoMCL-DB v6r1, which did include _C. auris_.
    1. Manually examine the _C. auris_ specific orthogroups.
- Also, this result brings up the possibility that some _C. auris_ adhesins may be missed, too. One idea is to take the top clusters with _C. albicans_ predicted adhesins, especially of the known adhesin families, and manually check the orthogroup in OrthoMCL v6r1 to see if any _C. auris_ gene fall in the same group.

```{r, echo=FALSE, warning=FALSE}
# merge the tables
frv.mcl5.sum$frv_high <- frv.tally$frv_high %>% 
  left_join(frv.mcl5.og %>% select(group, domains, keywords), by = c("group_id" = "group")) %>% 
  filter(Total > 3) %>% 
  select(group_id, domains, keywords)
```

#### 3. FaaPred

#### 4. FungalRV_`r frv.th` & FaaPred


_**Question**_

What are some of the most populated groups, and what percent of genes fall in those groups?

_**Exploratory data analyses**_

Tally the number of genes mapped to an OrthoMCL group in each strain
```{r tally_mapped}
frv.tally <- frv.cmbd %>% 
  # count the number of genes in each strain belonging to one orthogroup
  group_by(group_id) %>% 
  count(Strain) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Strain, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Caur = max(c(B11220,B11221,B8441)), total = Caur+CBS138+SC5314) %>% 
  select(group_id, Caur, Cgla = CBS138, Calb = SC5314, total) %>% 
  arrange(desc(total))

frv.tally %>% filter(total > 2)

# now let's do the same with the results based on OrthoMCL-DB v6r1
frv.mcl6.sum <- frv.cmbd6 %>% 
  group_by(group_id) %>% count(Strain) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Strain, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Caur = median(c(B11220,B11221,B8441)), total = Caur+CBS138+SC5314) %>% 
  select(group_id, Caur, Cgla = CBS138, Calb = SC5314, total) %>% 
  arrange(desc(total))

frv.mcl6.sum %>% filter(total > 2)
```

_**Discussion**_
- It appears that v6 and v5 do have a lot of differences. v6 is only accessible through the VEuPathDB's galaxy site. The OrthoMCL-DB website only provide download links, but not through its searches.
- Given the lack of information on v6, and the top orthogroup in v5 appears to be well supported (the _C. albicans_ ALS family), I will use v5 going forward.

### D. Examine the potential functions of the genes in the top orthogroups

#### Orthogroup members annotation

Now let's examine the top orthogroup in terms of membership and function.

In v5, `OG5_126579` has the most members represented. Let's see which genes belong to this group. To do so, we will need to use the ref_protein IDs,  which were used in our initial OrthoMCL submission, to retrieve gene names and other useful annotation. We will use the NCBI Entrez REST API, provided by the EUtils. Luckily, there is an R package that makes it a piece of cake to deal with such searches. The package is called [rentrez](https://cran.r-project.org/web/packages/rentrez/vignettes/rentrez_tutorial.html) (both entrez and rentrez are french words, interesting play on the names)

Fields of intersts:

| db | field | purpose |
|----|----|----|
| gene | name | common name |
| gene | genomicinfo | chromosome, start, stop |
| cdd | subtitle | summary info for the gene |
| cdd | abstract | longer description (can be truncated) |
| cdd | database | source of information |

First, we will use the rentrez interface to extract gene annotation info from NCBI databases
```{r entrez_link_gene_db, cache=TRUE, eval=FALSE}
# because we have a large number of IDs, we will use the "web history" feature, as documented here:
# https://cran.r-project.org/web/packages/rentrez/vignettes/rentrez_tutorial.html#web_history
IDs <- split(frv.reduced$protein_id, frv.reduced$Species)
# let's only look at C. albicans and C. glabrata for now. I think most of the C. auris genes are not annotated
IDs.to.map <- IDs[c("C_albicans", "C_glabrata", "S_cerevisiae")]
# "by_id=true" will retain the original ID. otherwise we won't know which new id maps to the input
gene.links <- lapply(IDs.to.map, function(x) {
  entrez_link(dbfrom = "protein", db = "gene", id = x, by_id = TRUE)})
# save(gene.links, file = "../../analysis/protein-family-classification/all-fungalRV-orthoMCL-v5/protein-to-gene-links-entrez.RData")
```

```{r gather_gene_info, eval=FALSE}
#if(!exists("gene.links")){
  #load("all-fungalRV-orthoMCL-v5/protein-to-gene-links-entrez.RData")
#}
# 1. extract the gene IDs only
protein_gene <- lapply(gene.links, function(x){
  sapply(x, function(y){ y$links$protein_gene})
}) # this is a list with three items corresponding to the three species

# 2. let's build a tibble to hold the ID mapping
IDs.mapped = tibble(Species = gsub('[0-9]+', '', names(unlist(IDs.to.map))),
                                   protein_id = unlist(IDs.to.map), 
                                   gene_id = unlist(protein_gene))

# 3. now we can retrieve the summary information data frame from the "gene" database
#    process the three species separately so as not to exceed the timeout limit.
gene.info <- lapply(protein_gene, function(x){
  entrez_summary(db = "gene", id = x)
})

# 4. we will extract the information we want from the records
gene.info.extract <- do.call(rbind, lapply(gene.info, function(sp){
  do.call(rbind, lapply(sp, function(x){
    c(x$uid, x$name, x$description, x$genomicinfo$chrloc, x$genomicinfo$chrstart, x$genomicinfo$chrstop)})
    )
  })
)
# ----------------- Long explanation, tl;dr : just skip it ------------------------
# the above command looks complicated, because it has to go through two layers
# of lists. it helps to know that gene.info contains three top items, each 
# corresponding to one of the three species submitted. Each species is a list of
# records corresponding to each gene_id passed on to entrez_summary()
# and our goal is to extract certain information for each gene.
# to read the code, start from the first lappy(): it essentially applies the 
# function(sp) to each of the three top layer items (species).
# for each species, the second lappy() iterates through each gene and extracts
# the uid, name, description, chromosome, start and end information. lapply returns
# those information for each gene as a list, which do.call(rbind, list()) takes in,
# treats each list as a row, and bind them into a matrix. Since this procedure is
# done for each of the three species, the first lapply would return a list of three
# matrices, which the outside do.call(rbind, list()) further binds them into a
# single matrix.
# ---------  if you stick till here, congratulations, -----------
# ------- you have just wasted some of your precious time!  -----

colnames(gene.info.extract) <- c("uid","gene_name","description","chromosome","start","stop")

# create a final gene.sum table to hold all gene related information with 
# a cross-reference protein_id to be connected to the OrthoMCL result
gene.sum <- bind_cols(IDs.mapped, gene.info.extract) %>% 
  mutate(start = as.integer(start), stop = as.integer(stop))
  
# save the result so this doesn't have to be run each time the R markdown is updated
save.image(file = "../../analysis/protein-family-classification/orthomcl-v5-mapping-analysis-cache.RData")
```

Now we can look at the genes in the top orthogroup, OG5_132045. Note that I didn't include the _C. auris_ genes, as 1) they often don't have a link to the "gene" database and 2) the essential information, e.g. functional annotation, will almost certainly be based on the _C. albicans_ genes anyway.

```{r example_og5_132045}
# get the protein IDs associated with the orthogroup
members <- frv.reduced %>% 
  filter(group_id == "OG5_126579") %>% 
  pull(protein_id)

gene.sum %>% 
  filter(protein_id %in% members) %>% 
  select(-description)
```

Above we looked at the gene locations and known names. That's still not very helpful. Let's see if we can gather more information by querying the Conserved Domain Database (cdd), which can be linked to from the "protein" database.

My goal is to count the number of members in each species/strain that belong to an orthogroup, ignoring those with just one member, as they have to be species specific. Then report the subtotals ordered by the total number of members in each orthogroup.

#### OrthoMCL-DB v6r1

```{r load_data_v6, echo=FALSE}
# the following file contains the mapped results
frv.mapped <- read_tsv("all-fungalRV-orthoMCL-v6r1/mappedGroups-20200516.txt", col_types = "ccciidd")
# merge with frv.res to provide meta information
frv.mapped6 <- frv.mapped %>% 
  left_join(frv.res, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, everything())

# the following file contains unmapped genes grouped by MCS algorithm
frv.mcs <- read.csv("all-fungalRV-orthoMCL-v6r1/MCS-20200516.tabular", sep = "\t", comment = "#", header = F, fill = T)
# let's reformat it to a long formatc (each member has its own row)
# and each group gets a unique ID
frv.mcs6 <- cbind(group_id = paste("mcs",1:nrow(frv.mcs),sep = "_"),
                 frv.mcs)
frv.mcs6.tbl <- as_tibble(frv.mcs6) %>% 
  # pivot_longer() replaces gather()
  # the first argument is the tibble, which is implicit; the second
  # argument is to define the columns to be reshaped, here we use
  # "-group_id" to mean all columns except for "group_id"
  pivot_longer(-group_id, names_to = "member", values_to = "protein_id") %>% 
  # now let's drop the rows with no protein_id (some rows in the 
  # original table has only two members, resulting in empty string
  # in the third column
  filter(protein_id != "") %>% 
  # finally, we will drop the unused column "member"
  select(-member)

# merge with frv.res to provide meta information
frv.mcs6.tbl <- frv.mcs6.tbl %>% 
  left_join(frv.res, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, everything())
```

How many of them were successfully mapped for each species/strain?

```{r percent_mapped_v6, echo=FALSE}
# combine the mapped and mcs data
frv.cmbd6 <- bind_rows(
  mapped = select(frv.mapped6, Species, Strain, protein_id, group_id = orthomcl_group_id),
  mcs = select(frv.mcs6.tbl, -Score), .id = "type")

# combined both mapped and MCS clustered
frv.cmbd6 %>% 
  group_by(Strain) %>% 
  summarize(mapped = sum(type == "mapped"), mcs = sum(type == "mcs")) %>% 
  right_join(frv.stat) %>% 
  adorn_totals()
```

_Dicussion_

- Some genes in _C. glabrata_ and _C. albicans_ do not map to the Orthogroups. For those genes, neither do they cluster with each other or with the other proteins in the predicted adhesin list. Because FungalRV predictions are not always accurate, it is likely that these genes are not adhesins. Alternatively, they could represent genuine adhesins, but don't share significant similarity with other adhesins at the sequence level
- It is puzzling why switching from v5 to v6r1 of OrthoMCL, we actually get more genes in _C. glabrata_ and _C. albicans_ to fall in the unmapped category.

- Below are some code to diagnose problems

```{r diagnose_unmapped_genes}
# extract protein IDs from the input and the output and compare them
cg.frv <- frv.res %>% filter(Strain == "CBS138", Score > 0) %>% pull(ID)
cg.mapped5 <- frv.mapped5 %>% filter(Strain == "CBS138") %>% pull(protein_id)
cg.mapped6 <- frv.mapped6 %>% filter(Strain == "CBS138") %>% pull(protein_id)

# identify proteins that are unmapped
cg.unmapped5 <- setdiff(cg.frv, cg.mapped5)
cg.unmapped6 <- setdiff(cg.frv, cg.mapped6)
cg.onlyin5 <- setdiff(cg.mapped5, cg.mapped6)
cg.onlyin6 <- setdiff(cg.mapped6, cg.mapped5)
```

I could then use the IDs to pull out the sequences from NCBI, and submit them to OrthoMCL's blast tool to see why they failed to match any orthogroups.

For example, "XP_447684.1" is mapped to OG6_128677 in v6r1, but failed to be mapped for v5. After checking the blasp results, I found that the gene actually yielded MANY hits in the v5 result, but all of the hits have cgla|XP_xxxx format, instead of the CAGL0Kxxx format, which suggests that the v5 and v6r1 OrthoMCL blast databases are quite different. As to why, despite having many hits in the v5 blastp result, it failed to be mapped with v5, I can't quite figure out.



```
# next let's look at the mappings
frv.mapped.sub <- faa.mapped %>% 
  count(Strain, orthomcl_group_id) %>% # group by strain and orthogroup ID, then count
  spread(key = Strain, value = n)  # spread the Strain variable so that all counts per strain is in the same row

faa.mapped.tot <- faa.mapped %>% 
  count(orthomcl_group_id, name = "total") %>% 
  filter(total > 1) # remove orthogroups with only one member across all species/strains

faa.mapped.final <- faa.mapped.sub %>% 
  right_join(faa.mapped.tot) %>% # this joins the two table and only retails rows that exist in mapped.tot
  arrange(desc(total))

print(faa.mapped.final, n=Inf)
```