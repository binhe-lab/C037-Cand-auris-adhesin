---
title: "Analyze predicted adhesins mapped to Orthogroups MCL v5"
author: "Bin He"
date: "5/31/2020"
output: 
  html_notebook:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
---

```{r setup, cache=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# set the root directory to be the output folder for OrthoMCL
# note that with the Rproject set, the default working directory
# is where the .Rproj file is.
knitr::opts_knit$set(root.dir = normalizePath("../../output/OrthoMCL/"))
knitr::opts_knit$get("root.dir")
```

```{r load_libraries, echo=FALSE}
# install the package if not already available
if (!requireNamespace("tidyverse", quietly = TRUE))
    install.packages("tidyverse")
if (!requireNamespace("rentrez", quietly = TRUE))
    install.packages("rentrez")

# load the package
suppressMessages(library(tidyverse))
suppressMessages(require(rentrez))
```

## Questions

Are the known and _predicted_ adhesin genes from _C. auris_, _C. albicans_ and _C. glabrata_ from the same group of adhesin families? In other words, do they use an ancestral pool of adhesin genes or did they evolve species-specific ones by co-option or _de novo_ evolution? If they share certain families, are the number of paralogs (members of a family) similar or different?

_Update 2020-05-31_

After my initial analysis of the OrthoMCL results (see [`OrthoMCL.Rmd`](https://github.com/binhe-lab/C037-Cand-auris-adhesin/blob/master/01-global-adhesin-prediction/analysis/protein-family-classification/OrthoMCL.Rmd)), I found that some of the orthogroups don't make obvious sense in terms of mediating adhesion, such as gene families annotated as alcohol dehydrogenases and other enzymes. Some of them may genuinely be relevant, such as aspartyl protease, which could be involved in cell wall remodeling triggered by host-fungal interaction. However, it does seem likely to me that the list of predicted adhesins contain an appreciable amount of false positives. To resolve this, I plan to take two approaches: 1) narrow down the list by including only those genes predicted by both FungalRV and FaaPred. This should reduce false positive rate, although it comes at the cost of higher false negative rates. 2) instead of analyzing the orthogroup mapping assuming all the predicted adhesins are correct, use the functional annotation for the orthogroups to vet the adhesins, and remove predictions that obviously _don't make sense_. Similarly, I can combine other predicted features such as Signal Peptide, GPI anchor and low complexity repeat regions to further eliminate potential false positives. In this document I will first try the FaaPred dataset.

## Approach
As previously, the OrthoMCL results were obtained using the VEuPathDB's [Galaxy site](http://veupathdb.globusgenomics.org/) to map the predicted adhesins from all five genomes to "orthogroups". These are pre-computed groups of putative orthologous protein sequences. These are calculated using the OrthoMCL program. Here is a [description](https://orthomcl.org/orthomcl/about.do#background) of how that is done. 

Briefly

- All-v-all BLASTP of the proteins.
- Compute percent match length
    - Select whichever is shorter, the query or subject sequence. Call that sequence S.
    - Count all amino acids in S that participate in any HSP (high scoring pairs, from BLAST local alignment).
    - Divide that count by the length of S and multiply by 100
- Apply thresholds to blast result. Keep matches with E-Value \< 1e-5 percent and match length \>= 50%
- Find potential in-paralog, ortholog and co-ortholog pairs using the Orthomcl Pairs program. (These are the pairs that are counted to form the Average % Connectivity statistic per group.)
- Use the MCL program to cluster the pairs into groups

## Data

- OrthoMCL output, including `mappedGroups.txt`, `MCS.tabular` and `paralogPairs.txt`.
    - `mappedGroups.txt`: the mapping between the proteins in the input file and the pre-calculated Orthogroups. 
    - `paralogPairs.txt`: pairwise distance calculated among the input sequences. 
    - `MCS.tabular`: the clustered proteins based on the `paralogPairs.txt`, which only include those sequences that don't get mapped to the existing Orthogroups.
- FungalRV predictions: `../FungalRV/all-fungalrv-results-20200529.txt`
- FaaPred predictions: `../Faapred/all-faapred-seq-names-20200531.txt`

### load data

Note! Please make sure that the threshold used below is correct before interpreting the remaining of this document
```{r load_adhesin_prediction}
# -------- Change Me! ----------
# 0. Set the fungalRV score threshold
#    The website application's default is 0, but the paper recommends 0.511 to achieve the best balance
#   between true positive and false positive
frv.th = 0.511
# -----------END ---------------

# 1. FungalRV
#    the following file contains the metadata for all genes
#    header: species, strains, protein_id and FungalRV score
#    threshold used by current version of Fungal RV: Score > 0 
frv.res <- read_tsv("../FungalRV/all-fungalrv-results-20200529.txt", comment = "#", col_types = "cccd", na = "Can't be processed")

# 2. FaaPred
faa.res <- scan("../Faapred/all-faapred-seq-names-20200531.txt", what = "string")

# 3. Make T/F variables for FungalRV and FaaPred results
adhesin <- frv.res %>% 
  mutate(fungalRV = ifelse(Score > frv.th, TRUE, FALSE),
         faapred = ifelse(ID %in% faa.res, TRUE, FALSE))
```

Load OrthoMCL mapping for proteins from the _Candida_ species
```{r load_orthomcl_mapping_no_scer}
# the following file contains the mapped results for the proteins with FungalRV score > 0 in all proteomes except for _S. cerevisiae_
frv.mapped <- read_tsv("all-fungalRV-orthoMCL-v5/mappedGroups-20200309.txt", col_types = "ccciidd")

# merge the frv.mapped with frv.res to provide gene information
frv.mapped.rest <- frv.mapped %>% 
  left_join(adhesin, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, group_id = orthomcl_group_id, frv_score = Score, fungalRV, faapred)

head(frv.mapped.rest, 3)
```

We need to process _S. cerevisiae_ data separately because instead of using the OrthoMCL mapping program, I downloaded the preprocessed results from [FungiDB](https://fungidb.org)

Note: the code below is _not_ run by default. Only run it when the _S. cerevisiae_ mapping data are updated.
```{r convert_scer_ID, echo=TRUE, eval=FALSE}
# the S. cerevisiae mapping data is downloaded from fungiDB (which is from OrthoMCL v5)
scer.mapped <- read_tsv("all-fungalRV-orthoMCL-v5/S_cerevisiae_orthoMCL_v5_download.txt", col_types = "ccccccccc")
# rearrange the columns and make any non-orthomcl-group-ids "NA"
scer.mapped <- scer.mapped %>%
  select(gene_id, description, orthogroup_id, pfam_id, pfam_description, geneName, entrez_id) %>% 
  mutate(orthogroup_id = ifelse(substr(orthogroup_id, 1, 4)=="OG5_", orthogroup_id, "NA"))

# collect predicted adhesins in S. cerevisiae by FungalRV
# note the threshold here is not altered, because my goal is to convert as many IDs 
# as entrez_link() allows doing so for all _S. cerevisiae_ is not possible due to 
# NCBI's API limit, but can be achieved by splitting the list into several batches 
# of hundreds. I didn't do so since we don't need the information for most of the 
# proteome (anything with score below zero are considered non-adhesin)
frv.scer <- adhesin %>% 
  filter(Species == "S_cerevisiae", Score > 0)

# translate these IDs to entrez_id so we can bring in the orthomcl mapping results
lnk <- entrez_link(dbfrom = "protein", id = frv.scer$ID, db = "gene", by_id = TRUE)
frv.scer$entrez_id <- sapply(lnk, function(x) x$link$protein_gene)

# pull in the orthogroup and other annotation
frv.mapped.scer <- frv.scer %>% 
  left_join(select(scer.mapped, group_id = orthogroup_id, entrez_id), by = c("entrez_id"="entrez_id")) %>% 
  select(Species, Strain, protein_id = ID, group_id, frv_score = Score, fungalRV, faapred)
write_tsv(frv.mapped.scer, "all-fungalRV-orthoMCL-v5/S_cerevisiae_mapped_w_entrezID.txt")
```

```{r process_and_merge_scer_data}
# read S. cerevisiae results generated above
frv.mapped.scer <- read_tsv("all-fungalRV-orthoMCL-v5/S_cerevisiae_mapped_w_entrezID.txt", col_types = "ccccdll")
# merge Scer results with the rest
frv.mapped.all <- rbind(frv.mapped.rest, frv.mapped.scer)

str(frv.mapped.all)
```

Note that _S. cerevisiae_ data contain a number of orthogroups with unusual group_id, such as  `r head(frv.mapped.scer %>% filter(substr(group_id,1,8) == "OG5_scer") %>% pull(group_id))`. These groups have only one member, that is, the _S. cerevisiae_ gene. However, when I search in the OrthoMCL-DB v6r1, some of them, like "OG5_scer|scer_s288c__YJL116C" coorespond to "OG6_1300006", which do contain 8 core members and 110 peripheral members.

Now let's load the Markov clustering results. This files contains the grouping produced by the MCL algorithm for those sequences that don't map to the orthomcl groups, and cluster them using the all-against-all blastp scores among themselves using the Markov Clustering Algorithm (MCL)
```{r load_mcs, warning=FALSE}
# the following file contains unmapped genes grouped by MCS algorithm
#frv.mcs <- read_tsv("all-fungalRV-orthoMCL-v5/MCS-20200605.tabular", comment = "#", col_types = "cc")
frv.mcs <- read_tsv("all-fungalRV-orthoMCL-v5/MCS-20200605.tabular", col_names = FALSE, col_types = "ccc")
frv.mcs$group_id <- paste("MCS",1:nrow(frv.mcs), sep = "_")
frv.mcs.long <- frv.mcs %>%  
  pivot_longer(-group_id, names_to = "member", values_to = "protein_id") %>% 
  # remove empty entries
  filter(!is.na(protein_id)) %>% 
  select(protein_id, group_id) %>% 
  left_join(adhesin, by = c("protein_id" = "ID")) %>% 
  select(Species, Strain, protein_id, group_id, frv_score = Score, fungalRV, faapred)

# merge with the mapped results
frv.cmbd <- bind_rows( mapped = frv.mapped.all, mcs = frv.mcs.long, .id = "type")
frv.cmbd %>% 
  filter(type == "mcs") %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n)
```
**Clearly, the MCS groups almost certainly represent the orthologs in the three _C. auris_ strains. No additional groups were recovered.**

**In the analysis below, we will use `frv.mapped.all`**

Lastly, we will load the meta-table downloaded from [fungiDB beta site](https://beta.fungidb.org/fungidb.beta/app/). Note that the OrthoMCL groups are based on OrthoMCL-v6r1, but the other meta-information are not specific to that version.
```{r load_fungidb_meta_table}
fungidb <- read_tsv("all-fungalRV-orthoMCL-v6r1/all_species_orthogroup_results_from_fungidb.txt", col_types = "ccccccicc", na = "N/A")
fungidb$organism <- with(fungidb, factor(organism, levels = unique(organism), labels = c("C_auris", "C_albicans", "C_glabrata", "S_cerevisiae")))
```

## Analysis

### A. How many predicted adhesins were successfully mapped in each species/strain?

First, let's check the prediction results.

- The "**Submitted**" represent the number of proteins getting a FungalRV score greater than zero - this is the default cutoff of the FungalRV web application, but is not the recommended cutoff as it potentially includes many false positives. We use this to "nominate" candidate adhesins, and also these were submitted to OrthoMCL program for mapping.
- The "**FungalRV**" group were those genes with a FungalRV score greater than the cutoff of 0.511, which is what the authors recommended.
- The "**FaaPred**" group were those among the FungalRV score > 0 that were predicted by FaaPred to be an adhesin. Because we didn't run FaaPred on ALL the genes, due to the 25 sequence limits of their web app and lack of access to their source code, this set is only a subset of what FaaPred would have predicted in these genomes.
- The "**Both**" grouop represent the intersection of FungalRV and FaaPred predictions.

```{r prediction_results, echo=FALSE}
# total number of adhesins submitted per species
frv.stat <- adhesin %>% 
  group_by(Species, Strain) %>% 
  summarize(FungalRV = sum(fungalRV, na.rm = T), 
            FaaPred = sum(faapred, na.rm = T), 
            Both = sum(fungalRV & faapred),
            Submitted = sum(Score > 0, na.rm = T), 
            Total = n())
print(frv.stat)
```

Next let's look at how many of the sequences submitted to OrthoMCL were successfully mapped.
```{r percent_mapped_v5, echo=FALSE}
# combined both mapped and MCS clustered
#frv.cmbd %>% 
#  group_by(Strain) %>% 
#  summarize(mapped = sum(type == "mapped"),self_group = sum(type == "mcs")) %>% 
#  right_join(frv.stat, by = c("Strain" = "Strain")) %>% 
#  mutate(unmapped = Submitted - mapped - self_group) %>% 
#  select(Species, Strain, mapped, self_group, unmapped, Submitted)

frv.mapped.all %>% 
  count(Strain) %>% 
  right_join(frv.stat, by = c("Strain" = "Strain")) %>% 
  mutate(mapped = n, unmapped = Submitted - mapped) %>% 
  select(Species, Strain, mapped, unmapped, Submitted)
```

Note that although all _S. cerevisiae_ proteins appear to be "mapped", `r length(frv.mapped.scer %>% filter(substr(group_id,1,8) == "OG5_scer") %>% pull(group_id))` belong to those unusual "OG5_scer|scer_S288c_xxx" groups.

### B. Reduce the three _C. auris_ strains to a single superset
While the individual strains could reveal variation within species, the unequal assembly quality of the three strains' genome makes this approach less convincing. Instead, we could take advantage of the three genomes to come up with a superset of adhesins that "exist" in the _C. auris_ population. Here the idea is to use the OrthoMCL mapping to remove redundant genes. Among the _C. auris_ genes that map to one of the OrthoMCL groups, we pick one of them as a representative, e.g. choose the one that is the longest.

#### Count the number of genes in each _C. auris_ strain belonging to every orthogroup
Let's first examine the grouping of the _C. auris_ proteins, including the OrthoMCL groups and the MCL clustering result for those not mapped to the existing groups (only the top seven rows are shown, the rest have 0 or 1 member in each strain)
```{r examine_C_auris_proteins, echo=FALSE}
# extract only the C. auris entries
caur <- frv.mapped.all %>% 
  filter(Species == "C_auris", frv_score > 0) 

# let's check the number of genes in each orthogroup by strain
caur.wide <- caur %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  arrange(desc(B11220+B11221+B8441))
head(caur.wide, n = 7)
```
_Discussion_

We can see that most of the orthogroups contain one or zero gene in each strain. A few orthogroups contain multiple members. I think it will be interesting to pull one of the latter groups out, e.g. OG5_132045, extract all the sequences in that group and build a gene geneaology tree.

#### Reconstruct the gene tree for a representative orthogroup
```{r extract_multiple_member_groups, eval=FALSE}
example_set <- frv.mapped.all %>% filter(group_id == "OG5_132045") %>% pull(protein_id)
cat(example_set, file = "all-fungalRV-orthoMCL-v5/subset/OG5_132045.txt", sep = "\n")
```

Next I used a custom script to extract the fasta sequences, which were aligned and submitted to a tree construction algorithm to infer the gene geneaology relationship.

![**Figure 1. Best RAxML tree for OG5_132045 (run from 20 random maximal parsimony tree, no bootstrap)**](../../output/OrthoMCL/all-fungalRV-orthoMCL-v5/OG5_132045/RAxML_bestTree.test.png)

_Discussion_

It's clear that gene duplications happened in _C. albicans_ and _C. auris_. Within _C. auris_, it appears that most of the genes are shared across the three strains, suggesting that the gene duplications happened before the split of those three strains from their common ancestor.

#### Reduce the three _C. auris_ sets to a pan _C. auris_ set

Next I'd like to reduce three _C. auris_ sets into a pan-species set. Since all I need  in the following analysis is to count the _number_ of proteins in each orthogroup, I don't really care which member I retain and which I leave out. To do so, I will create a new variable in `caur` that records the strain with the largest number of proteins in each group. Then, using both `group_id` and this new variable, I can obtain a list of `protein_id` that I want to retain.
```{r reduce_caur_set, echo=FALSE}
caur.strains <- c("B11220","B8441","B11221") # arranged in the order of genome assembly completeness. B11220 is the most recently updated, and is the most well assembled; B8441 is still the reference strain in most databases, e.g. fungidb
caur.reduced <- caur.wide %>% 
  # find out which strain has the largest number of members in each group
  mutate(use.strain = caur.strains[which.max(c(B11220, B8441, B11221))]) %>% 
  select(group_id, use.strain) %>% 
  # append this information to the caur data frame (subset of the frv.cmbd)
  right_join(caur, by = c("group_id" = "group_id")) %>% 
  # only retain rows where the Strain matches the `use.strain`
  filter(Strain == use.strain) %>% 
  select(Species, Strain, protein_id, group_id)
```

Original set
```{r original_set, echo = FALSE}
caur %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  arrange(desc(B11220+B11221+B8441)) %>% 
  head(n = 3)
```

Reduced set
```{r reduced_set, echo=FALSE}
caur.reduced %>% 
  select(Strain, group_id) %>% 
  group_by(group_id) %>% 
  count(Strain) %>% 
  pivot_wider(id_cols = group_id, names_from = Strain, values_from = n) %>% 
  mutate(total = sum(c(B11220,B11221,B8441), na.rm = TRUE)) %>% 
  arrange(desc(total)) %>%
  select(group_id, B11220, B11221, B8441) %>% 
  head(n = 3)
```

Now let's make a new data frame holding the reduced _C. auris_ set and the other species
```{r reduced_data_frame}
# get the list of C. auris protein_id that need to be removed
caur.remove <- setdiff(caur$protein_id, caur.reduced$protein_id)
# remove tho corresponding entries from the combined data set 
frv.reduced <- frv.mapped.all %>% 
  filter(!protein_id %in% caur.remove)
```

### C. Proportion of shared vs species-specific (predicted) adhesins

This analysis will be done on four different subsets of the data.

1. All genes with a FungalRV score greater than zero -- this is what we submitted to OrthoMCL, and also what is used in many other analyses as the input set. It probably contains a fair number of false positives.
1. Genes with a FungalRV score greater than `r frv.th` -- this is the recommended score cutoff for FungalRV.
1. Genes with a FungalRV score greater than 0 and also predicted by FaaPred to be adhesins.
1. Genes that are predicted by FungalRV (recommended threshold) and FaaPred

#### 1. FungalRV_0
_Goal_

Use a bar or pie chart to represent the number (or proportion) of predicted adhesins that fall in one of the four categories
1. Unmapped
1. Mapped to a group that is not shared with any of the remaining 3 species.
1. Mapped to a group that is shared by one other species.
1. Mapped to a group that is shared with two other species.
1. Mapped to a group that is shared across all four species.

_Approach_

1. Subset the data
1. Separately count the number of proteins in each species and group them based on whether they belong to an orthogroup or self_group that is shared by at least one other species.

Let's first examine the group membership, ordered by the size of each group in the reduced data set in descending order.
```{r orthogroup_membership}
# subset the data
frv.tally <- frv.reduced %>% 
  # no filtering
  # count the number of genes in each strain belonging to one orthogroup
  group_by(group_id) %>% 
  count(Species) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Species, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Total = C_albicans+C_auris+C_glabrata+S_cerevisiae) %>% 
  select(group_id, C_auris, C_albicans, C_glabrata, S_cerevisiae, Total) %>% 
  arrange(desc(Total))

frv.tally %>% filter(Total > 2)
```

Next let's compute the number of genes in each species belonging to the four groups.
```{r}
# for each orthogroup, count the number of species with at least one member
frv.group.Nsps <- frv.reduced %>%
  group_by(group_id) %>%
  summarize(N_sps = length(unique(Species))) %>% 
  mutate(N_sps = factor(N_sps))

# for each species, count the number of genes belonging to groups with 4,3,2 or 1 species representation
frv.group.sps <- frv.reduced %>%
  # bring in the species number computed above
  left_join(frv.group.Nsps) %>% 
  group_by(Species) %>% 
  count(N_sps) %>% 
  # calculate the proportions
  # from https://stackoverflow.com/questions/40249943/adding-percentage-labels-to-a-bar-chart-in-ggplot2
  mutate(pct = prop.table(n)) 

ggplot(frv.group.sps, aes(x = Species, y = n, fill = N_sps, label = scales::percent(pct, accuracy = 1))) + 
  geom_bar(stat = "identity", width = 0.5) + 
  geom_text(position = position_stack(vjust = 0.5), size = 3) +
  coord_flip() + scale_fill_brewer(palette = "Paired") + theme_minimal()
```

Now let's learn something about the top OG groups, e.g. what functional domains do these orthogroups have in common? What EC and GO terms are they associated with?

To answer this question, we will collect the list of orthogroup id's and paste them manually onto the OrthoMCL-DB website's [search group id tool](https://orthomcl.org/orthomcl/showQuestion.do?questionFullName=GroupQuestions.ByNameList), and then download the output as a custom table.

```{r orthogroup_output, include = FALSE}
# print the top orthogroups' IDs
cat(paste(frv.mcl5.sum$group_id, collapse = ","))
# copy and paste the list to https://orthomcl.org/orthomcl/showQuestion.do?questionFullName=GroupQuestions.ByNameList
# then choose the columns to report. I chose
# num. sequences | average % identity | domains | EC numbers | Group | Keywords
```

```{r add_og_information}
# read in the results
frv.mcl5.og <- read_tsv("all-fungalRV-orthoMCL-v5/v5-orthogroups-summary-20200521.txt", col_types = "cidccc", na = "N/A")

# merge the tables
frv.tally %>% 
  left_join(select(frv.mcl5.og, group, domains, keywords), by = c("group_id" = "group")) %>% 
  filter(Total > 3) %>% 
  select(group_id, domains, keywords)
```

#### 2. FungalRV_`r frv.th`

#### 3. FaaPred

#### 4. FungalRV_`r frv.th` & FaaPred


_**Question**_

What are some of the most populated groups, and what percent of genes fall in those groups?

_**Exploratory data analyses**_

Tally the number of genes mapped to an OrthoMCL group in each strain
```{r tally_mapped}
frv.tally <- frv.cmbd %>% 
  # count the number of genes in each strain belonging to one orthogroup
  group_by(group_id) %>% 
  count(Strain) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Strain, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Caur = max(c(B11220,B11221,B8441)), total = Caur+CBS138+SC5314) %>% 
  select(group_id, Caur, Cgla = CBS138, Calb = SC5314, total) %>% 
  arrange(desc(total))

frv.tally %>% filter(total > 2)

# now let's do the same with the results based on OrthoMCL-DB v6r1
frv.mcl6.sum <- frv.cmbd6 %>% 
  group_by(group_id) %>% count(Strain) %>% 
  # spread the table wider, one row per orthogroup
  pivot_wider(names_from = Strain, values_from = n, values_fill = list(n = 0)) %>% 
  mutate(Caur = median(c(B11220,B11221,B8441)), total = Caur+CBS138+SC5314) %>% 
  select(group_id, Caur, Cgla = CBS138, Calb = SC5314, total) %>% 
  arrange(desc(total))

frv.mcl6.sum %>% filter(total > 2)
```

_**Discussion**_
- It appears that v6 and v5 do have a lot of differences. v6 is only accessible through the VEuPathDB's galaxy site. The OrthoMCL-DB website only provide download links, but not through its searches.
- Given the lack of information on v6, and the top orthogroup in v5 appears to be well supported (the _C. albicans_ ALS family), I will use v5 going forward.

### D. Examine the potential functions of the genes in the top orthogroups


#### Orthogroup members annotation

Now let's examine the top orthogroup in terms of membership and function.

In v5, `OG5_126579` has the most members represented. Let's see which genes belong to this group. To do so, we will need to use the ref_protein IDs,  which were used in our initial OrthoMCL submission, to retrieve gene names and other useful annotation. We will use the NCBI Entrez REST API, provided by the EUtils. Luckily, there is an R package that makes it a piece of cake to deal with such searches. The package is called [rentrez](https://cran.r-project.org/web/packages/rentrez/vignettes/rentrez_tutorial.html) (both entrez and rentrez are french words, interesting play on the names)

Fields of intersts:

| db | field | purpose |
|----|----|----|
| gene | name | common name |
| gene | genomicinfo | chromosome, start, stop |
| cdd | subtitle | summary info for the gene |
| cdd | abstract | longer description (can be truncated) |
| cdd | database | source of information |

First, we will use the rentrez interface to extract gene annotation info from NCBI databases
```{r entrez_link_gene_db, cache=TRUE}
# because we have a large number of IDs, we will use the "web history" feature, as documented here:
# https://cran.r-project.org/web/packages/rentrez/vignettes/rentrez_tutorial.html#web_history
IDs <- split(frv.mapped5$protein_id, frv.mapped5$Strain)
# let's only look at C. albicans and C. glabrata for now. I think most of the C. auris genes are not annotated
IDs.Ca.Cg <- IDs[c("CBS138", "SC5314")]
# "by_id=true" will retain the original ID. otherwise we won't know which new id maps to the input
gene.links <- lapply(IDs.Ca.Cg, function(x) {
  entrez_link(dbfrom = "protein", db = "gene", id = x, by_id = TRUE)})
```

```{r gather_gene_info}
# extract the gene IDs only
protein_gene <- lapply(gene.links, function(x){
  sapply(x, function(y){ y$links$protein_gene})
})
# 2. let's build a tibble to hold the gene annotation information
gene.sum <- tibble(Strain = c(rep("Cgla", length(IDs$CBS138)), rep("Calb", length(IDs$SC5314))),
                   protein_id = c(IDs$CBS138, IDs$SC5314),
                   gene_id = c(protein_gene$CBS138, protein_gene$SC5314))
# 3. now we can retrieve the summary information data frame from the "gene" database
gene.info <- entrez_summary(db = "gene", id = gene.sum$gene_id)

# 4. we will extract the information we want from the records
gene.info.extract <- do.call(rbind, lapply(gene.info, function(x){
  c(x$uid, x$name, x$description, x$genomicinfo$chrloc, x$genomicinfo$chrstart, x$genomicinfo$chrstop)}))
#    the above command first uses lapply to iterate through the gene.info list and extracts the useful columns. it returns a list of vectors. do.call() then supplies that list to rbind(), which normally takes discrete vectors as input. This returns a matrix
colnames(gene.info.extract) <- c("uid","gene_name","description","chromosome","start","stop")
gene.info.extract <- as_tibble(gene.info.extract)
gene.sum <- gene.sum %>% 
  left_join(gene.info.extract, by = c("gene_id"="uid")) %>% 
  mutate(start = as.integer(start), stop = as.integer(stop))
save.image(file = "../../analysis/protein-family-classification/orthomcl-v5-mapping-analysis-cache.RData")
```

Now we can look at the genes in the top orthogroup, OG5_132045. Note that I didn't include the _C. auris_ genes, as 1) they often don't have a link to the "gene" database and 2) the essential information, e.g. functional annotation, will almost certainly be based on the _C. albicans_ genes anyway.

```{r example_og5_132045}
# get the protein IDs associated with the orthogroup
members <- frv.mapped5 %>% 
  filter(orthomcl_group_id == "OG5_126579") %>% 
  pull(protein_id)

gene.sum %>% 
  filter(protein_id %in% members) %>% 
  select(-description)
```

Above we looked at the gene locations and known names. That's still not very helpful. Let's see if we can gather more information by querying the Conserved Domain Database (cdd), which can be linked to from the "protein" database.

My goal is to count the number of members in each species/strain that belong to an orthogroup, ignoring those with just one member, as they have to be species specific. Then report the subtotals ordered by the total number of members in each orthogroup.

#### OrthoMCL-DB v6r1

```{r load_data_v6, echo=FALSE}
# the following file contains the mapped results
frv.mapped <- read_tsv("all-fungalRV-orthoMCL-v6r1/mappedGroups-20200516.txt", col_types = "ccciidd")
# merge with frv.res to provide meta information
frv.mapped6 <- frv.mapped %>% 
  left_join(frv.res, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, everything())

# the following file contains unmapped genes grouped by MCS algorithm
frv.mcs <- read.csv("all-fungalRV-orthoMCL-v6r1/MCS-20200516.tabular", sep = "\t", comment = "#", header = F, fill = T)
# let's reformat it to a long formatc (each member has its own row)
# and each group gets a unique ID
frv.mcs6 <- cbind(group_id = paste("mcs",1:nrow(frv.mcs),sep = "_"),
                 frv.mcs)
frv.mcs6.tbl <- as_tibble(frv.mcs6) %>% 
  # pivot_longer() replaces gather()
  # the first argument is the tibble, which is implicit; the second
  # argument is to define the columns to be reshaped, here we use
  # "-group_id" to mean all columns except for "group_id"
  pivot_longer(-group_id, names_to = "member", values_to = "protein_id") %>% 
  # now let's drop the rows with no protein_id (some rows in the 
  # original table has only two members, resulting in empty string
  # in the third column
  filter(protein_id != "") %>% 
  # finally, we will drop the unused column "member"
  select(-member)

# merge with frv.res to provide meta information
frv.mcs6.tbl <- frv.mcs6.tbl %>% 
  left_join(frv.res, by = c("protein_id"="ID")) %>% 
  select(Species, Strain, protein_id, everything())
```

How many of them were successfully mapped for each species/strain?

```{r percent_mapped_v6, echo=FALSE}
# combine the mapped and mcs data
frv.cmbd6 <- bind_rows(
  mapped = select(frv.mapped6, Species, Strain, protein_id, group_id = orthomcl_group_id),
  mcs = select(frv.mcs6.tbl, -Score), .id = "type")

# combined both mapped and MCS clustered
frv.cmbd6 %>% 
  group_by(Strain) %>% 
  summarize(mapped = sum(type == "mapped"), mcs = sum(type == "mcs")) %>% 
  right_join(frv.stat) %>% 
  adorn_totals()
```

_Dicussion_

- Some genes in _C. glabrata_ and _C. albicans_ do not map to the Orthogroups. For those genes, neither do they cluster with each other or with the other proteins in the predicted adhesin list. Because FungalRV predictions are not always accurate, it is likely that these genes are not adhesins. Alternatively, they could represent genuine adhesins, but don't share significant similarity with other adhesins at the sequence level
- It is puzzling why switching from v5 to v6r1 of OrthoMCL, we actually get more genes in _C. glabrata_ and _C. albicans_ to fall in the unmapped category.

- Below are some code to diagnose problems

```{r diagnose_unmapped_genes}
# extract protein IDs from the input and the output and compare them
cg.frv <- frv.res %>% filter(Strain == "CBS138", Score > 0) %>% pull(ID)
cg.mapped5 <- frv.mapped5 %>% filter(Strain == "CBS138") %>% pull(protein_id)
cg.mapped6 <- frv.mapped6 %>% filter(Strain == "CBS138") %>% pull(protein_id)

# identify proteins that are unmapped
cg.unmapped5 <- setdiff(cg.frv, cg.mapped5)
cg.unmapped6 <- setdiff(cg.frv, cg.mapped6)
cg.onlyin5 <- setdiff(cg.mapped5, cg.mapped6)
cg.onlyin6 <- setdiff(cg.mapped6, cg.mapped5)
```

I could then use the IDs to pull out the sequences from NCBI, and submit them to OrthoMCL's blast tool to see why they failed to match any orthogroups.

For example, "XP_447684.1" is mapped to OG6_128677 in v6r1, but failed to be mapped for v5. After checking the blasp results, I found that the gene actually yielded MANY hits in the v5 result, but all of the hits have cgla|XP_xxxx format, instead of the CAGL0Kxxx format, which suggests that the v5 and v6r1 OrthoMCL blast databases are quite different. As to why, despite having many hits in the v5 blastp result, it failed to be mapped with v5, I can't quite figure out.



```
# next let's look at the mappings
frv.mapped.sub <- faa.mapped %>% 
  count(Strain, orthomcl_group_id) %>% # group by strain and orthogroup ID, then count
  spread(key = Strain, value = n)  # spread the Strain variable so that all counts per strain is in the same row

faa.mapped.tot <- faa.mapped %>% 
  count(orthomcl_group_id, name = "total") %>% 
  filter(total > 1) # remove orthogroups with only one member across all species/strains

faa.mapped.final <- faa.mapped.sub %>% 
  right_join(faa.mapped.tot) %>% # this joins the two table and only retails rows that exist in mapped.tot
  arrange(desc(total))

print(faa.mapped.final, n=Inf)
```