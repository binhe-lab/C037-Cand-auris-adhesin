---
title: "Analyze XP_028889033 family evolution and adhesin properties"
author: "Bin He"
date: "11/01/2020"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    toc_depth: 5
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r load_libraries, echo = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!requireNamespace("treeio", quietly = TRUE))
    BiocManager::install("treeio")
if (!requireNamespace("ggtree", quietly = TRUE))
    BiocManager::install("ggtree")
library(tidyverse)
library(cowplot)
library(RColorBrewer)
library(ggtree)
library(treeio)
```

## Goal

Analyze the adhesin properties of the XP_028889033 homologs (putative adhesin in _C. auris_)
This is version 3 of the analysis, using the updated homologs on 2021-02-05

## Build datasets
First get the basic information about the 100 sequences in this study. I decide to write a simple Python script to extract such info.
```bash
# edit the PYTHON path below to match your local system
~/sw/miniconda3/bin/python extract_seq_info.py
```

Load in the sequence information.

> note that I need to manually edit the sequence ids for four sequences from fungidb, because I used their refseq_id when retrieving their chromosomal locations.

| GRYC ID | Refseq_ID|
|---------|----------|
| CLUG_05233   | XP_002615218.1 |
| CPAR2_600430 | XP_036662815.1 |
| CPAR2_806390 | XP_036665262.1 |
| CPAR2_806420 | XP_036665265.1 |

```{r load_seq_info}
sps.list <- c("Cduobushaemulonis","Cpseudohaemulonis","Chaemuloni","Cauris","Clusitaniae","Dhansenii","Cparapsilosis","Lelongisporus","Ctropicalis","Cdubliniensis","Calbicans","Sstipitis","Klactis","Ncastellii","Cglabrata","Nbracarensis","Ndelphensis","Nnivariensis")
seqInfo <- read_tsv("data/XP_028889033_homologs.tsv", comment = "#", col_types = "ccci") %>% 
  mutate(species_id = factor(species, levels = sps.list), species = NULL)
chrLoc <- read_tsv("data/XP_028889033_homologs_chr_loc.tsv", col_types = cols()) %>% 
  mutate(id = ifelse(is.na(accession), gene_id, accession), 
         accession = NULL, 
         species_id = factor(species_id, levels = sps.list),
         relLoc = round(chrstart/chrL, 3))

seqInfo <- seqInfo %>% 
  left_join(chrLoc) %>% 
  mutate(assemblystatus = factor(assemblystatus, levels = c("Complete Genome","Chromosome","Contig","Scaffold"), 
                                 labels = c("Chromosome", "Chromosome", "Partial", "Partial")),
         species_gr = factor(species_id, labels = 
                               c(rep("MDR",3),"Cauris","Clusitaniae","Dhansenii", rep("parapsilosis",2),
                                 rep("albicans",3), "Sstipitis", rep("Saccharomycetaceae",6)))) %>% 
  select(name, id, source, starts_with("gene"), starts_with("species"), strain, starts_with("assembly"),
         length, n_seqs, starts_with("chr"), relLoc)
```

## Species tree
Below is the relationship between the species studied in this analysis.
```{r, fig.width=6, fig.height = 5, warning=FALSE}
sps.tree <- read.tree(file = "data/20200724-species-tree.nwk")
p <- ggtree(sps.tree, ladderize = FALSE) + xlim(0,12) + scale_y_reverse() +
  geom_tiplab(size = 4, align = TRUE, linesize = .5, fontface = 4) +
  geom_cladelabel(node = 22,  label = "Clavispora", offset = 3.7, color = "magenta", 
                  offset.text = 0.2, angle = 270, hjust = .5, extend = 0.3) + # Clavispora
  geom_cladelabel(node = 23,  label = "MDR", offset = 4.5, color = "purple", fontface = 2,
                  offset.text = 0.2, angle = 270, hjust = .5, extend = 0.3) + # MDR
  geom_cladelabel(node = 27,  label = "Candida", offset = 2.7, color = "salmon", 
                  offset.text = 0.2, angle = 270, hjust = .5, extend = 0.3) + # Candida
  geom_cladelabel(node = 29,  label = "albicans", offset = 3.5, color = "red", fontface = 2,
                  offset.text = 0.2, angle = 270, hjust = .5, extend = 0.3) + # albicans
  geom_cladelabel(node = 31,  label = "Saccharomycetaceae", offset = 2.7, color = "grey20", 
                  offset.text = 0.2, angle = 270, hjust = .5, extend = 0.3) # Sacchromycetaceae
p
```
**Fig. 1 Phylogenetic relationship of the species analyzed in this study.** This species tree is based on the Maximum likelihood phylogeny from Muñoz _et al._ 2018 (PMID: 30559369) for the most part, with the exception of the species in the Saccharomycetaceae family, which is based on Gabaldón _et al._ 2016 (PMID: 27493146).

> Note that he placement of _Debaryomyces hansenii_ differs between the above two publications. The former placed it closer to the Clavispora genus while the latter placed it closer to the Candida genus. We based ours on the first publication. Another large scale phylogenetic analysis (Shen _et al._ 2018 (PMID: 30415838)), also placed _D. hansenii_ closer to the Candida genus. However, in both studies, which reported bootstrap support values in addition to the phylogeny, the support for the part of the tree involving _D. hansenii_ is relatively low suggesting uncertainty in resolving the relationship. We chose to place _D. hansenii_ closer to the Clavispora genus because this is more congruent with the gene tree for the Hil family proteins we inferred below.

## Gene tree
### RAxML tree before reconciliation
```{r, fig.width=8, fig.height=6}
gene.tree <- read.tree("data/RAxML_gene_tree.clustalo_3701250_rooted.nwk")
df <- seqInfo %>% select(label = name, species_id, species_gr)
gene.tree <- full_join(gene.tree, df, by = "label")
ggtree(gene.tree, ladderize = TRUE) + 
  #scale_y_reverse() +
  geom_tippoint(aes(color = species_gr)) +
  scale_color_manual(name = "Clades",
                     values = c("MDR" = "purple",
                                "Cauris" = "plum2",
                                "Clusitaniae" = "magenta", 
                                "Dhansenii" = "gray50",
                                "Sstipitis" = "steelblue",
                                "parapsilosis" = "salmon", 
                                "albicans" = "red", 
                                "Saccharomycetaceae" = "grey20")) +
  theme(text = element_text(size = 14))
```
**Fig. 2 RAxML inferred gene tree for Hyr/Iff-Like (HIL) family members in Ascomycetes.** The branch length is proportional to the inferred substitions per site. The tree is manually rooted on the Saccharomycetaceae family, which is the outgroup to both the Candida and Clavispora genera and whose Hil homologs form a distinct group. Protein sequence names are not shown for brevity, but are color coded based on the species (groups) they belong to. The clade color code is nested such that if a sequence belongs to both a species and a clade, e.g. _C. auris_ and the MDR clade, the sequence will be colored based on the smaller phylogenetic unit, i.e. _C. auris_.

### Gene tree after reconciliation
We reconciled the gene tree with the species tree in Notung 2.9. The purpose of this step is to reconstruct the history of gene duplications and losses (transfers don't apply to this case) and to rearrange weakly supported parts of the gene tree to reduce the total event score in accordance with the evolutionary parsimony principal.

Briefly, after both the gene tree and the rooted species tree (see above) were loaded into the graphic user interface, the rooting analysis was run and the branch receiving the highest root score was the same as the manually chosen branch as shown in Fig. 2, namely the ancestral branch for all the Saccharomycetaceae proteins. After rooting and reconciliation, a total of 59 duplications and 47 losses were inferred. The reconciled gene tree was then rearranged. In this step, weakly supported branches -- those with rapid bootstrap score < 90% -- were allowed to be swapped and the event score, calculated as a weighted sum of the total loss and duplication events, was calculated for each rearrangement. Among all rearranged gene tree topologies, the one with the lowest event score had 42 duplications and 12 losses. This is the gene tree that is shown below.
```{r, fig.width=8, fig.height=7}
gene.tree.rec <- read.nhx(file = "output/notung/RAxML_bipartitions.clustalo_3701250_rearranged90.nhx")
gene.tree.rec <- full_join(gene.tree.rec, df, by = "label")
ggtree(gene.tree.rec, ladderize = TRUE, branch.length = "none") + 
  geom_label(aes(x = branch, label =  ifelse(S %in% c("Saccharomycetaceae", "CUG-Ser1", "DH", "SS") & node != 106, S, NA)),  fill = "gray", size = 3) +
  geom_text(aes(label = ifelse(D == "Y", "D", NA)), hjust = -0.4, size = 2, color = "red") +
  geom_tippoint(aes(color = species_gr)) +
  scale_color_manual(name = "Clades",
                     values = c("MDR" = "purple",          "Cauris" = "plum2",
                                "Clusitaniae" = "magenta", "Dhansenii" = "gray50",
                                "Sstipitis" = "steelblue", "parapsilosis" = "salmon", 
                                "albicans" = "red",  "Saccharomycetaceae" = "grey20")) +
  theme(text = element_text(size = 14))
```
**Fig. 3 Reconciled and rearranged gene tree for Hyr/Iff-Like (HIL) family members in Ascomycetes.** The cladogram shows only the topology of the tree, with endpoints colored in the same way as in Fig. 2. A red "D" next to an internal node indicates an inferred gene duplication event at that node. The labels with gray background highlight the main features of the tree: 1) the Saccharomycetaceae sequences form the outgroup, suggesting there was no ancient duplication prior to the divergence of the family and the remaining species; 2) the CUG-Ser1 clade, which contains both the Candida and Clavispora genera, forms two duplicate groups, suggesting an early duplication event in the clade; 3) the top CUG-Ser1 branch further experienced extensive duplications _independently_ in the Clavispora genus, labeled by the outgroup _D. hansenii_ (DH), and the Candida genus, labeled by the outgroup _S. stipitis_ (SS). 

### Gains and losses on species tree
```{r, fig.width=5, fig.height=5}
# read in notung parsed event summary stats
notung.stat <- read_tsv("output/notung/RAxML_bipartitions.clustalo_3701250_notung_event_summary.txt", col_types = 'cii')
sps.tree %>% 
  full_join(notung.stat, by = "label") %>% 
  as_tibble() %>% 
  mutate(label = paste0(str_sub(label, 1, 1), ". ", str_sub(label, 2))) %>% 
  as.treedata() %>% 
  ggtree(ladderize = FALSE) + scale_y_reverse() +
  geom_tiplab(size = 4, fontface = "italic", offset = 0.1) + xlim(0,11) +
  geom_hilight(node = 22, fill = "hotpink", alpha = 0.15) + # Clavispora
  geom_hilight(node = 23, fill = "purple", alpha = 0.15)  + # MDR
  geom_hilight(node = 27, fill = "hotpink", alpha = 0.15) + # Candida
  geom_hilight(node = 29, fill = "red", alpha = 0.15)     + # albicans
  geom_hilight(node = 31, fill = "grey20", alpha = 0.15)  + # Sacchromycetaceae
  geom_text(aes(label = duplications), hjust = 3, vjust = -.3,
            size = 3, color = "red", fontface = 2) +
  geom_text(aes(label = paste0("/", losses)), hjust = 1.3, vjust = -.3,
            size = 3, color = "grey20", fontface = 2) +
  geom_label(aes(label = ifelse(duplications >= 3, duplications, NA)), hjust = 2.1,
             vjust = -.11, size = 3, color = "red", fill = "yellow1", fontface = 2,
             label.size = 0, label.padding = unit(0.12, "lines"))
ggsave("output/img/20210622-species-tree-with-gains-losses.png", width = 5, height = 5)
```
**Fig. 4 Inferred gene duplications and losses in the Hyr/Iff-Like (HIL) family in Ascomycetes.** The cladogram shows the species relationship with shadings as in Figure 1. The numbers on top of each branch are the inferred duplications (red) and losses (black) using Notung 2.9. Yellow highlight emphasize the branches that experience three or more duplications.

_**Conclusions**_

1. The Hil family **independently** expanded in the Candida and Clavispora genera. The most significant expansion occurred within the albicans clade in the Candida genus and the MDR clade in the Clavispora genus.
1. Many species in the Saccharomycetaceae family have no homologs in this family based on our blast criteria. This suggests that the gene family has contracted and any remaining homologs are shorter than 500 amino acid and thus likely to not play an adhesin function.
## Homologous protein length
```{r}
p.tree <- sps.tree %>% as_tibble() %>% 
  mutate(label = paste0(str_sub(label, 1, 1), ". ", str_sub(label, 2))) %>% 
  as.treedata() %>% ggtree(ladderize = FALSE) + xlim(0,14) + scale_y_reverse() +
  geom_tiplab(size = 4, align = TRUE, linesize = .5, fontface = "italic", offset = 0.1) +
  geom_hilight(node = 22, fill = "hotpink", alpha = 0.2) + # Clavispora
  geom_hilight(node = 23, fill = "purple", alpha = 0.2)  + # MDR
  geom_hilight(node = 27, fill = "hotpink", alpha = 0.2) + # Candida
  geom_hilight(node = 29, fill = "red", alpha = 0.2)     + # albicans
  geom_hilight(node = 31, fill = "grey20", alpha = 0.2)    # Sacchromycetaceae
```

```{r plot_prot_length, fig.width=8, fig.height=5}
# plot the length distribution of the homologs in each species
p <- ggplot(seqInfo, aes(x = reorder(species_id, desc(species_id)), y = length)) + 
  geom_boxplot(outlier.shape = NA) + geom_hline(yintercept = 500, linetype = 2) +
  geom_dotplot(binwidth = 100, binaxis = "y", stackdir = "center", dotsize = 0.5, 
               binpositions = "all", fill = rgb(0,0,0,0.5), color = rgb(0,0,0,0.6)) + 
  coord_flip() + 
  labs(title = "Distribution of XP_028889033 homologs' protein length") +
  theme(axis.title.y = element_blank(), axis.text.y = element_blank())
  
plot_grid(p.tree, p, align = "h", ncol = 2, rel_widths = c(1,1.5), scale = c(1.08,1))
```
_**Discussion**_

- The one sequence below 500 a.a. is from _N. delphensis_, which is labeled as a partial CDS.
- Majority of the proteins in the list are 500-2000 a.a., with a few exceptionally long
- Not only do Saccharomycetaceae species have fewer Hil family homologs, the ones they have are also short (< 1000 a.a.) with the exception of _C. glabrata_

## Chromosomal locations
While I was performing BLAST on FungiDB to identify homologs of our protein, I noticed that many of the hits appear to be at the beginning and end of the chromosomes. To see if there is a systematic trend in the chromosomal locations, I collected this information for all 99 homologs in the list. Note however, not all genomes are assembled to the chromosomal level, and as a result, the locations for the proteins in those species/strains would be relative to a contig or scaffold. My rationale is that if the contig or scaffold is close to choromosomal length (although that varies by at least an order of magnitude), I could at least look at them separately.

```{r, fig.width = 8, fig.height = 7}
p <- seqInfo %>% 
  mutate(chr = paste(species_id, chraccver, sep = "_")) %>% 
  ggplot(aes(x = chr)) + 
  geom_segment(aes(xend = chr, y = 1, yend = chrL, color = assemblystatus), size = 2) +
  geom_segment(aes(xend = chr, y = chrstart, yend = chrstart+7000), color = "red", size = 3)
p + coord_flip() + theme_classic() + scale_color_manual(values = c("grey50", "grey")) +
  theme(axis.text.y = element_text(size = 5),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.85,0.85),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  labs(y = "Position on chromosome or scaffold", x = "Chromosomes / Scaffolds", color = "Assembly Status") + 
  ggtitle("Chromosomal locations of XP_028889033 homologs")
ggsave("output/img/20210213-homologs-chr-loc.png", bg = "transparent", width = 6, height = 5)
```

```{r, fig.width = 8, fig.height = 4}
p <- seqInfo %>% filter(!(chrL < 1e6 & assemblystatus == "Partial")) %>% 
  mutate(dTip = ifelse(relLoc < 0.5, relLoc, 1-relLoc)) %>% 
  ggplot(aes(x = dTip)) + facet_wrap(~assemblystatus) +
  xlab("Distance from Chromosome or Scaffold Ends") + labs(fill = "Species group") + 
  scale_x_continuous(breaks = seq(0,0.5,by = 0.1))
p + geom_histogram(binwidth = 0.05)
ggsave("output/img/20210213-distribution-on-chromosome-or-scaffolds-histogram-grey.png", width = 5, height = 3)
p + geom_histogram(aes(fill = species_gr), binwidth = 0.05) + scale_fill_brewer(palette = "Paired")
ggsave("output/img/20210213-distribution-on-chromosome-or-scaffolds-histogram.png", width = 6, height = 3)
```

**Discussion**

- Visually there appear to be some enrichment towards the chromosome ends overall.
- Breakdown by species revealed stronger signals in the albicans clade and the MDR clade.
- To properly test for enrichment in the chromosomal ends would require documenting the gene density on the affected chromosomes. If the different chromosomes have dramatically different gene distributions, proper tests may not be straightforward to construct. Instead, a bootstrapping approach could be easier to conceive and apply.

### Are members of this protein family enriched in the subtelomeric regions?
A recent long-read sequencing study for _C. glabrata_ annotated 31 novel ORFs, of which 24 are GPI-Cell Wall Proteins. The authors cited previous literature supporting the  in the subtelomeric regions [Xu 2020](https://doi.org/10.1111/mmi.14488). This plus the empirical observation above showing an apparent enrichment towards the chromosome ends lead me to ask whether there is indeed a significant enrichment among this family of proteins in the subtelomeric regions.

To formally test this hypothesis, I need to account for the background gene density differences along the chromosomes. The idea is to compare the chromosomal positions for this group of proteins compared with the gene densities on the chromosomes they reside on. We will restrict our analysis to those genomes with a chromosomal level assembly status for obvious reasons.

>**Update 2021-06-21** We will also include C. auris B11221 as we know its assembly is nearly at the chromosomal level

```{r decide_which_species_to_use}
use.sps <- seqInfo %>% 
  filter(assemblystatus == "Chromosome" | species_id == "Cauris") %>% 
  select(species_id, assembly) %>% unique()
use.sps
# now let's also create a new tibble for our homologs from these species
fg.freq <- chrLoc %>% 
  filter(species_id %in% use.sps$species_id) %>% 
  # remove the one C. auris gene located on an unassembled fragment
  filter(!(species_id == "Cauris" & chr_name == "scaffold00015")) %>% 
  # change the scaffold name to chromosome name (they correspond)
  mutate(chr_name = gsub("scaffold0+", "", chr_name))
```

To conduct this test, we first need to prepare and compute the background gene densities. To do this, we will gather the genome assembly files for the selected species, read them into R, and generate a table that contains one row for each gene, with its gene ID, chromosome number, chromosome length and the start position expressed as a percentage measured from the chromosome ends.

```{r compute_background_freq}
# 1. prepare file names
#   get all file names that ends with "feature_table.txt.gz", which contain the gene annotation
feature.files <- list.files(path = "data/assembly-info/", pattern = "*feature_table.txt.gz$")
names(feature.files) <- sapply(str_split(feature.files, pattern = "_"), function(x) {
  paste(x[1], x[2], sep = "_")
})
#   get all file names that ends with "assembly_report.txt", which contain the chromosomal length
assembly.files <- list.files(path = "data/assembly-info/", pattern = "*assembly_report.txt$")
names(assembly.files) <- sapply(str_split(assembly.files, pattern = "_"), function(x) {
  paste(x[1], x[2], sep = "_")
})
use.sps$FeatureFile <- feature.files[use.sps$assembly]
use.sps$AssemblyFile <- assembly.files[use.sps$assembly]

# 2. read in the assembly information
feature.col.names <- c("feature","class","assembly","assembly_unit","seq_type","chromosome","genomic_accession","start","end","strand","product_accession","non_redundant_refseq","related_accession","name","symbol","GeneID","locus_tag","feature_interval_length","product_length","attributes")
assembly.col.names <- c("chromosome","seq_role","assign_molecule","type","gb_acc","relationship",
                        "chraccver","assembly_unit","seqL","ucsc_name")
compute.bg.freq <- function(row){
  assembly.file <- row["AssemblyFile"]
  assembly <- read_tsv(paste0("data/assembly-info/",assembly.file), comment = "#",
                       col_names = assembly.col.names, col_types = "ccccccccic")
  feature.file <- row["FeatureFile"]
  feature <- read_tsv(paste0("data/assembly-info/",feature.file), col_names = feature.col.names,
                      col_types = "ccccccciicccccccciic", skip = 1)
  res <- feature %>% 
    filter(feature == "mRNA") %>% 
    # these feature tables are organized hierarchically, with the top level being "gene"
    # the next level one of "mRNA", "ncRNA", "tRNA" or "rRNA". we only count protein-coding genes, i.e.
    # "mRNA". the reason I didn't select the "CDS" feature type is because in a small number of cases,
    # one mRNA feature contains more than one CDS feature, possibly due to splicing or alternative 
    # translational start site
    select(chromosome, start, end) %>% 
    left_join(select(assembly, chromosome, chraccver, seqL), by = c("chromosome" = "chromosome")) %>%
    mutate(relLoc = round(start / seqL, 3))
  return(res)
}
# apply the function to the genomes, but leave out C. auris
bg.freq <- apply(filter(use.sps, species_id != "Cauris"), MARGIN = 1, compute.bg.freq)
names(bg.freq) <- use.sps %>% filter(species_id != "Cauris") %>% pull(species_id)
```

Separately calculate the background frequency for _C. auris_
```{r}
compute.bg.freq.cau <- function(){
  assembly.col.names <- c("chromosome","seq_role","assign_molecule","type","gb_acc","relationship",
                        "chraccver","assembly_unit","seqL","ucsc_name")
  row = use.sps %>% filter(species_id == "Cauris") # C. auris entry
  assembly.file <- row["AssemblyFile"]
  assembly <- read_tsv(paste0("data/assembly-info/",assembly.file), comment = "#",
                       col_names = assembly.col.names, col_types = "ccccccccic") %>% 
    filter(as.integer(str_sub(chromosome, -2, -1)) <= 7)
  feature.file <- row["FeatureFile"]
  feature <- read_tsv(paste0("data/assembly-info/",feature.file), col_names = feature.col.names,
                      col_types = "ccccccciicccccccciic", skip = 1)
  res <- feature %>% 
    filter(feature == "mRNA") %>% 
    select(chraccver = genomic_accession, start, end) %>% 
    right_join(select(assembly, chromosome, chraccver, seqL), by = "chraccver") %>%
    mutate(relLoc = round(start / seqL, 3),
           chromosome = gsub("scaffold0+","",chromosome))
  return(res)
}
bg.freq$Cauris <- compute.bg.freq.cau()
```

Let's take a look at the gene density in one of the genomes, e.g. _C. albicans_

```{r}
bg.freq$Dhansenii %>% ggplot(aes(x = relLoc)) + 
  geom_density() + facet_wrap(~ chromosome) + ggtitle("D. hansenii") + theme(plot.title = element_text(hjust = 0.5))
```
> We can see that there is typically a drop in gene density towards the chromosome ends, which makes the observation that our protein family are biased towards the chromosomal ends even more striking.

_**Note** that the above plot was wrong due to the way the density() function estimates the kernel density, which assumes that the data outside the range are possible, in this case smaller than 0 and greater than 1. This leads to the underestimation of the density at the boundaries because it includes regions outside the possible range, where there is no observation. See this post for discussion https://github.com/tidyverse/ggplot2/issues/3387_

Below I use the `geom_histogram` function instead, with breaks specified manually. This results in a density distribution that is pretty flat across the chromosomes.
```{r}
bg.freq$Dhansenii %>% ggplot(aes(x = relLoc)) + 
  geom_histogram(breaks = seq(0,1,0.05)) +
  facet_wrap(~ chromosome) + ggtitle("D. hansenii") + theme(plot.title = element_text(hjust = 0.5))
ggsave("output/img/20210303-dhansenii-chromosome-gene-density-histogram.png", width = 6, height = 4)
```

In order to compare the distribution of _all_ genes in different bins of the chromosomes to the homologs in our case study, we can divide each chromosome in the `nrow(use.sps)` genomes into an arbitrary number of bins after "folding" them in half, e.g. 0-10%, 10-20%, 20-30%, 30-40% and 40-50%. To be able to visually compare the distribution of our homologs and the genome background, we will create a special "chromosome" class that will be our homologs and combine them with the `bg.freq` table.
```{r, fig.width = 10}
freq.bins <- c(-0.001, seq(0.1, 0.5, 0.1)); freq.binsL <- c(0, freq.bins[-1])
freq.label <- paste0(head(freq.binsL, -1)*100,"-",tail(freq.binsL, -1)*100,"%")
bg.freq.tb <- bind_rows(bg.freq, .id = "species") %>% 
  mutate(fold.relLoc = ifelse(relLoc <= 0.5, relLoc, 1-relLoc),
         bin = cut(fold.relLoc, breaks = freq.bins, labels = freq.label))

# add the homologs
fg.freq <- fg.freq %>% 
  mutate(fold.relLoc = ifelse(relLoc <= 0.5, relLoc, 1-relLoc),
         bin = cut(fold.relLoc, breaks = freq.bins, labels = freq.label)) 
freq.plot <- fg.freq %>%
  mutate(chromosome = "X") %>%  # we label the homologs as X to make it a separate class
  select(species = species_id, chromosome, bin) %>% 
  bind_rows(select(bg.freq.tb, species, chromosome, bin))
# plot
freq.plot %>% 
  mutate(species = paste0(substr(species, 1, 1), ". ", substr(species, 2, 15))) %>% 
  ggplot(aes(x = chromosome, group = bin, fill = bin)) + geom_bar(position = position_fill()) +
  facet_wrap(~ species, scales = "free_x") + scale_fill_brewer(type = "qual", palette = 3) +
  scale_y_continuous(name = "Proportion", trans = "reverse") + theme_cowplot() + panel_border()

ggsave("output/img/20210303-compare-homologs-chromosomal-locations-to-bg.png", width = 8, height = 6)
```
In the plot above, "X" is a special category that collects our homologs. We can see that the distribution of these proteins on the chromosome deviate from the background. Note that a few of the seven species contain only 1-2 PF11765 homologs -- these include the three in the middle row -- and we should interpret their homologs distribution with caution.

Now that we have the background gene frequencies computed, we can start constructing a test that tests for significant departure in the chromosomal locations of our protein family from the background frequencies. One idea is to divide the chromosome into equal-sized bins and use the frequencies of _all_ genes in each bin as the multinomial probabilities in the null hypothesis. If our proteins were randomly selected from each chromosome without regard to their location, we would expect their locations to conform to the background frequencies. This can be tested using an exact multinomial test or an approximate Chi-square test or G-test. Since we don't distinguish the two ends of a chromosome, we can "fold" the chromosome "in half" and measure each gene's location as a percentage from the closer end, i.e. the relative location ranging from 0%-50%. If we can reject the null hypothesis, that constitutes evidence that the proteins from our group are not randomly selected from the background set.

**Result of multinomial test**

```{r multinomial_test}
# install XNomial package for the multinomial exact test function
# https://cran.r-project.org/web/packages/XNomial/vignettes/XNomial.html#e1
while(!require(XNomial))
  suppressMessages(install.packages("XNomial"))
# calculate pooled background frequency
bg.cnt <- cut(bg.freq.tb$fold.relLoc, breaks = freq.bins, labels = freq.label) %>% tabulate()
fg.cnt <- tabulate(fg.freq$bin)
xmulti(obs = fg.cnt, expr = bg.cnt, detail = 3)
```
Note that the three _P_-values correspond to three approaches of testing the goodness-of-fit. The LLR, which stands for Log Likelihood Ratio, is generally preferred. But all three said the same thing: the observation deviates from the background frequency significantly. By looking at the plots above, it is clear that the deviation is due to the excess of our homologs residing in the 0-10% bin, which is the tip of the chromosomes.

The test above assumes that the gene density along all chromosomes in the seven species follow the same distribution. The empirical observation supports that hypothesis. Should that to be not the case, we could also account for the variability in gene density distribution between species or even between chromosomes within a species. The idea is to first collect the chromosomes that our homologs come from, and then randomly sample the **same** number of genes as the number of our homologs on that chromosome. Do this for all of the homolog-containing chromosomes, we would obtain one random sample. Repeat this process 1000 times or more, we will then get the pseudosample, which we can use to compare with our observations. Here we need to come up with a statistic that summarizes each of our observation or pseudosample. For example, we could calculate the median % location for each sample, and ask where our observation lie relative to the pseudosamples. I'll skip this approach for now since the first appraoch appears to be OK given the similar gene density distribution across chromosomes and species.

## Adhesin predictions
### SVM based predictions
[FungalRV](http://fungalrv.igib.res.in/) and [FaaPred](http://bioinfo.icgeb.res.in/faap/) are two Support Vector Machine (SVM) based prediction algorithms that use sequence features such as amino acid composition (frequency, physiochemical properties etc.) as input and train Machine Learning models to distinguish fungal adhesins from non-adhesins.
```{r adhesin_prediction}
frv.th = 0.511 # recommended FungalRV score threshold
frv <- read_tsv("output/FungalRV/fungalRV_result.txt", skip = 3, col_names = c("name","frv.score"), col_types = "cd") %>% 
  mutate(name = str_sub(name, 2), frv.pred = frv.score > frv.th)
faa <- read_tsv("output/web-download/faapred_result.txt", col_names = c("name","faa.score","faa.pred"), col_types = "cdc") %>% 
  mutate(faa.pred = ifelse(faa.pred == "Adhesin", TRUE, FALSE))
if("frv.score" %in% names(seqInfo))
  seqInfo <- select(seqInfo, -frv.score, -frv.pred, -faa.score, -faa.pred)
seqInfo <- seqInfo %>% left_join(frv) %>% left_join(faa)
```

```{r}
df <- seqInfo %>% 
  group_by(species_id) %>% 
  summarize(n = n(), 
            fungalRV = sum(frv.score > 0.511), faapred = sum(faa.pred, na.rm = T), 
            both = sum(frv.score > 0.511 & faa.pred),
            mean.frv = round(mean(frv.score), 2), mean.faa = round(mean(faa.score, na.rm = T), 2))

dt <- DT::datatable(df, options = list(dom = 't', pageLength = 20, ordering = FALSE), 
                caption = "Summary of Adhesin Prediction Results")
# the following code is from https://www.r-bloggers.com/2020/05/mimic-excels-conditional-formatting-in-r-2/
brks <- stats::quantile(x <- df[[2]], probs = seq(.05, .95, .05), na.rm = TRUE)
#clrs <- colorRampPalette(c("#fcdbdb", "#ff1515"))(length(brks)+1)
clrs <- colorRampPalette(brewer.pal(n = 4, name = "Reds"))(length(brks)+1)
for (j in 2:5){
  # Create breaks for shading column values high to low
  # Create shades of green for backgrounds
  # Format cells in j-th column
  dt <- DT::formatStyle(dt, j, backgroundColor = DT::styleInterval(brks, clrs))
}
dt
```
```{r}
# see https://yulab-smu.top/treedata-book/chapter7.html#attach-operator
# the attach operator "%<+%" works on ggtree objects and requires the first column
# of the data frame to contain the tip labels
```

### GPI-anchor prediction
GPI-anchored proteins are characterized by an N-terminal signal peptide, which would direct the protein to the secretary pathway, and a C-terminal GPI-anchor peptide, which would be cleaved and replaced by the GPI-anchor, allowing the protein to be tethered to the cell wall.

For signal peptide, I used SignalP server. Its latest version is 5.0. But I also ran the sequences through their 4.1 version, with two settings. The results of the latter two are almost identical, except for one sequence "XP_024711350.1", which is only included in the sensitive version, and has a probability lower than 0.5.

```{r signalP, fig.width=5, fig.height=5}
# Signal peptide
gff.names <- c("id", "source", "name", "start", "end", "prob", "na1", "na2", "na3")
signalp5 <- read_tsv("output/web-download/signalp_5.0.gff", comment = "#", col_names = gff.names, col_types = "ccciidccc")

if("signalp" %in% names(seqInfo))
  seqInfo <- select(seqInfo, -signalp)

seqInfo <- left_join(seqInfo, select(signalp5, name = id, prob), by = c("name" = "name")) %>% 
  mutate(signalp = !is.na(prob)) %>% select(-prob)
```

For GPI-anchor prediction, I used the [PredGPI server](http://gpcr.biocomp.unibo.it/predgpi/).
```{r gpi}
tmp <- read_delim("output/web-download/predgpi_result.txt", delim = "|", col_names = c("name","fp","omega"))
pred.gpi <- tmp %>% 
  mutate(name = str_sub(name,2,-2), # remove > and the trailing space
         fp = as.numeric(str_sub(fp, 9, -2)), # extract the numeric part
         is.gpi = fp <= 0.01,    # based on the cutoff of the PredGPI server (prob < 99% -> not GPI-anchored)
         omega = str_sub(omega, 8),
         cleaveRes = str_sub(omega, 1, 1),
         cleavePos = as.integer(str_sub(omega, 3))
         ) %>% 
  left_join(select(seqInfo, name, length), by = c("name" = "name"))

# remove the column if it already exists
if("pred.gpi" %in% names(seqInfo))
  seqInfo <- select(seqInfo, -pred.gpi)
seqInfo <- left_join(seqInfo, select(pred.gpi, name, pred.gpi = is.gpi), by = c("name"="name"))
```

```{r}
df1 <- seqInfo %>% 
  group_by(species_id) %>% 
  summarize(SignalP = sum(signalp), GPI_Pred = sum(pred.gpi), Pass = sum(frv.score > 0.511 & signalp & pred.gpi)) %>% 
  right_join(df) %>% 
  select(species = species_id, Total = n, Pass, FungalRV = fungalRV, FaaPred = faapred, SignalP, GPI_Pred)

dt1 <- DT::datatable(df1, options = list(dom = 't', pageLength = 20, ordering = FALSE), 
                caption = "Summary of Adhesin Prediction Results")
# the following code is from https://www.r-bloggers.com/2020/05/mimic-excels-conditional-formatting-in-r-2/
brks <- stats::quantile(x <- df1[[2]], probs = seq(.05, .95, .05), na.rm = TRUE)
#clrs <- colorRampPalette(c("#fcdbdb", "#ff1515"))(length(brks)+1)
clrs <- colorRampPalette(brewer.pal(n = 4, name = "Reds"))(length(brks)+1)
for (j in 2:8){
  # Create breaks for shading column values high to low
  # Create shades of green for backgrounds
  # Format cells in j-th column
  dt1 <- DT::formatStyle(dt1, j, backgroundColor = DT::styleInterval(brks, clrs))
}
dt1
```

**Summary**

- Most of the Hil homologs in Ascomycetes passed both the GPI-anchor predictions and also the FungalRV predictor, suggesting that they are likely to be cell wall proteins and may play an adhesin function (FaaPred predicted fewer adhesins, but the overall pattern doesn't change).
- 
```{r}
# saving the table output to a png file 
# https://stackoverflow.com/questions/60287652/how-to-save-a-table-i-created-with-dt-datatable-into-a-high-quality-image
DT::saveWidget(dt1, "output/misc/tmp.html")
webshot::webshot("output/misc/tmp.html", "output/img/20210623-homologs-prediction-summary.png")
```

## Build feature map for homologs

The goal is to produce a cartoon-like plot for each homolog outlining their main features, such as the locations of the PFam domains (mainly the Hyp_reg_CWP), locations of the signal peptide and GPI-anchor, distribution of TANGO sequences. Note that all these features can be represented as a range with associated metadata. So the first step is to collect the coordinates of the features

```{r}
# GPI-anchor
# use pred.gpi
# Pfam domains
pfam <- read_tsv("raw-output/HMMER-HMMScan-Pfam-hits.tsv", col_types = "ciiiicciiidddiic")
# save feature file for Jalview examination
# pfam %>% filter(grepl("XP_028889033",seq_id)) %>% select(hmm_name, seq_id, envelope_start, envelope_end) %>% mutate(featuretype = "domain") %>% write_tsv("XP_028889033_features.jalview")
# I manually edited the feature file, so I commented out the line above to avoid accidentally 
# overwriting my own edits

# feature set
# structure: id  feature  start  end
feature <- bind_rows(
  seqInfo %>% mutate(type = "entire protein", start = 1) %>% select(id = name, type, start, end = length),
  pfam %>% select(id = seq_id, type = hmm_name, start = envelope_start, end = envelope_end),
  # extend the signal peptide segment by 10 amino acids to make it more visible
  signalp5 %>% mutate(type = "SignalP", end = end + 10) %>% select(id, type, start = start, end),
  # extend the GPI-anchor C-terminus segment by 20 amino acids to make it more visible
  pred.gpi %>% filter(is.gpi) %>% mutate(type = "GPI-anchor", start = cleavePos-10) %>% 
    select(id = name, type, start, end = length)
)
feature$type = ordered(feature$type, levels = c("entire protein", "Hyphal_reg_CWP", "Asp", "Candida_ALS", "Flocculin", "Flocculin_t3", "Hyr1", "PT", "SignalP", "GPI-anchor"))
feature.colors <- c("grey", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#fdbf6f", "#ff7f00", "#cab2d6", "#e31a1c", "#6a3d9a")
# in order to plot properties of the sequences in an order that is consistent with the sequences' position in the gene tree
genetreeOrder <- scan("reorder_by_gene_tree.txt", what = "character")
feature$id <- ordered(feature$id, levels = rev(genetreeOrder))
```

```{r plot_features, fig.height=8, fig.width=10}
p <- ggplot(feature, aes(x = id, y = start)) + 
  geom_segment(aes(xend = id, yend = end, color = type), size = 2)
p + coord_flip() + theme_classic() + scale_color_manual(values = feature.colors) +
  theme(axis.text.y = element_text(size = 5),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.85,0.35),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  ylim(1, 4500) + labs(y = "Position in sequence", x = "Sequences", color = "Domain / Feature") + 
  ggtitle("Domain architecture")
ggsave("img/20210214-homologs-domains-schematics.png", bg = "transparent", width = 7, height = 7)
```

## Serine/Threonine content

S/T sites are potential sites for O-glycosylation, which could increase the rididity of the stalk of the protein and allow the N-terminal domain to protrude out of the cell wall facing the exterior. More evidence for the importance of O-glycosylation in a serine/threonine-rich domain can be found [here](https://ec.asm.org/content/10/10/1317.long).

To determine the S/T frequency in the XP_028889033 homologs, I ran the program `freak` from the EMBOSS suite with the parameters of 100 aa sliding window and a step size of 10 aa. After reformating the output, the rest of the analysis is accomplished below.

```{r S_T_freq}
# load data
ST.freq <- read_tsv("raw-output/ST_freq_100_10_freak.out.gz", col_types = "cid")
S.freq <- read_tsv("raw-output/S_freq_100_10_freak.out.gz", col_types = "cid")
T.freq <- read_tsv("raw-output/T_freq_100_10_freak.out.gz", col_types = "cid")
# convert sequence name column to an ordered list sorted based on the gene tree sequence
ST.freq <- ST.freq %>%  mutate(id = ordered(id, levels = rev(genetreeOrder))) # this will produce the desired order
S.freq <- S.freq %>%  mutate(id = ordered(id, levels = rev(genetreeOrder))) # this will produce the desired order
T.freq <- T.freq %>%  mutate(id = ordered(id, levels = rev(genetreeOrder))) # this will produce the desired order
```

```{r plot_ST_freq, fig.height=8, fig.width=10}
ggplot(ST.freq, aes(x = id, y = pos)) +  geom_tile(aes(fill = freq)) +
  coord_flip() + theme_classic() + scale_fill_distiller(palette = "RdGy", limits = c(0, 0.8), oob = scales::squish, breaks = seq(0, 0.6, by = 0.2)) +
  theme(axis.text.y = element_text(size = 5),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.85,0.35),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  ylim(1, 4500) + labs(y = "Position in sequence", x = "Sequences", color = "Frequency") + 
  ggtitle("Serine/Threonine frequency in 100 aa sliding windows")
ggsave("img/20201223-homologs-ST-freq-100aa-window.png", bg = "transparent", width = 7, height = 7)
```
```{r, fig.width=10}
ST.comb <- bind_rows("S/T" = ST.freq, S = S.freq, T = T.freq, .id = "Var") %>% 
  mutate(Var = ordered(Var, levels = c("S/T","S","T")))
ggplot(ST.comb, aes(x = id, y = pos)) + geom_tile(aes(fill = freq)) + 
  facet_wrap(~Var, scales = "fixed") + theme_minimal() +
  coord_flip() + scale_fill_distiller(palette = "RdGy", limits = c(-0.05, 0.55), oob = scales::squish,
                                      breaks = seq(0,0.5,by=0.1)) +
  #scale_fill_gradient2(low = "#1a1a1a", high = "#b30000", midpoint = 0.2) +
  theme(axis.text.y = element_blank(),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.95,0.24),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  ylim(1, 4500) + ylab("Position in sequence") + xlab("Sequences") + 
  ggtitle("Ser/Thr frequency in 100 aa windows (frequency > 0.55 replaced by 0.55)")
ggsave("img/20201223-ST-freq-composite.png", width = 8, height = 4.5)
```


```{r, eval=FALSE, include=FALSE}
suppressPackageStartupMessages(library(ggtree))
geneTree <- read.tree("XP_028889033_homologs_gene_tree.nwk")
```

## TANGO prediction of $\beta$-aggregation prone sequences

The amyloid-like $\beta$-aggregation prone sequences have the ability to mediate self-aggregation, which boosts the local concentration of the adhesin molecules on the cell-surface. Similar to the S/T frequency above, we would like to use the output from the prediction algorithm, TANGO, to visulize the distribution of such sequence motifs along the length of the XP_028889033 homolog sequences.

TANGO predictions and the subsequent extraction of $\beta$-aggregation prone sequences were documented in separate Python script, README files and the `tango.Rmd`.
```{r tango_sequences, fig.height=8, fig.width=10}
# here we only look at the extracted tango sequences
tango <- read_tsv("tango_summary_table.tsv.gz", col_types = "cciiidddicc")
# reorder the sequences for plotting
tango$name <- ordered(tango$name, levels = rev(genetreeOrder))
# plot
p1 <- ggplot(filter(feature, type == "entire protein"), aes(x = id, y = start)) + 
  geom_segment(aes(xend = id, yend = end), size = 2, color = "grey40")
p2 <- geom_segment(data = tango, aes(x = name, xend = name,  y = ifelse(start-4 >= 0, start-4, 0), yend = end + 4, color = median), size = 2)
p3 <- geom_segment(data = filter(feature, type == "Hyphal_reg_CWP"), aes(x = id, y = start, xend = id, yend = end), size = 2, color = "#1f78b4")
p1 + p2 + p3 + coord_flip() + theme_classic() + 
  scale_color_distiller(type = "seq", palette = 17, direction = 1) +
  theme(axis.text.y = element_text(size = 5),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.85,0.25),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  ylim(-2, 4500) + labs(y = "Position in sequence", x = "Sequences", color = "Median TANGO score") + 
  ggtitle("TANGO hits with Hyphal_reg_CWP domain masked")
ggsave("img/20210110-tango-score-segment.png", width = 7, height = 7)
```

```{r, eval=FALSE, include=FALSE}
# read in TANGO output
# tango output are stored as gzipped files for each individual sequence. we need to read in all of the files into a list of tibbles
tango.output.files <- list.files(path = "tango-output", pattern = "*.txt.gz", include.dirs = T)
ltango <- lapply(tango.output.files, function(x) {
  read_tsv(paste0("tango-output/",x), col_types = "icddddd") %>% select(res, aa, Aggregation)
  })
names(ltango) <- gsub(".txt.gz","",tango.output.files)
tango.output <- bind_rows(ltango, .id = "id")
# the id column stores only the refseq_id, without the species name portion. to make sure that the sequences
# are plotted in the desirable order, we do the following
names(genetreeOrder) <- gsub("_[A-Za-z]+$","", genetreeOrder, perl = TRUE)
tango.ordered <- tango.output %>% 
  mutate(new_id = genetreeOrder[id], ordered_id = ordered(new_id, levels = rev(genetreeOrder))) %>% 
  select(ordered_id, res, aa, aggregation = Aggregation)
```

Now we can plot them the same way as we plotted the S/T frequencies:
```{r, eval=FALSE, include=FALSE}
p <- ggplot(tango.ordered, aes(x = ordered_id, y = res)) + geom_tile(aes(fill = aggregation)) + 
  scale_fill_gradient(limits = c(5,100), breaks = c(5,20,50,100), low = "white", high = "yellow", trans = "sqrt") +
  coord_flip() +  theme_classic() +
  theme(axis.text.y = element_text(size = 5),
        axis.line.y = element_blank(), axis.ticks.y = element_blank(),
        axis.line.x = element_blank(), axis.ticks.x = element_blank(),
        legend.position = c(0.9,0.8),
        panel.background = element_rect(fill = alpha("lightblue",0.5))) +
  ylim(1, 4500) + ylab("Position in sequence") + xlab("Sequences") + ggtitle("TANGO predicted aggregation score")
p
ggsave("img/20200811-tango-score-tile.png", p, bg = "transparent", width = 7, height = 7)
```

